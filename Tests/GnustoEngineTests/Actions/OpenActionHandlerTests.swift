import CustomDump
import Testing

@testable import GnustoEngine

@MainActor
@Suite("OpenActionHandler Tests")
struct OpenActionHandlerTests {
    let handler = OpenActionHandler()

    @Test("Open item successfully")
    func testOpenItemSuccessfully() async throws {
        // Arrange
        let initialProperties: Set<ItemProperty> = [.container, .openable]
        let closedBox = Item(
            id: "box",
            name: "wooden box",
            parent: .location("startRoom")
        )
        closedBox.properties = initialProperties

        let game = MinimalGame(items: [closedBox])
        let mockIO = await MockIOHandler()
        let mockParser = MockParser()
        let engine = GameEngine(
            game: game,
            parser: mockParser,
            ioHandler: mockIO
        )

        // Initial state check
        #expect(engine.itemSnapshot(with: "box")?.hasProperty(.open) == false)
        #expect(engine.gameState.changeHistory.isEmpty == true)

        let command = Command(verbID: "open", directObject: "box", rawInput: "open box")

        // Act: Call the engine's execute method to use the full enhanced pipeline
        await engine.execute(command: command)

        // Assert State Change
        let finalItemState = engine.itemSnapshot(with: "box")
        let expectedProperties: Set<ItemProperty> = [.container, .openable, .open, .touched]
        #expect(finalItemState?.properties == expectedProperties, "Item should gain .open and .touched properties")

        // Assert Output
        let output = await mockIO.flush()
        expectNoDifference(output, "You open the wooden box.")

        // Assert Change History
        #expect(engine.gameState.changeHistory.count == 1)
        let recordedChange = engine.gameState.changeHistory.first
        let expectedChange = StateChange(
            entityId: .item("box"),
            propertyKey: .itemProperties,
            oldValue: .itemProperties(initialProperties),
            newValue: .itemProperties(expectedProperties)
        )
        expectNoDifference(recordedChange, expectedChange)
    }

    @Test("Open item that is already touched")
    func testOpenItemAlreadyTouched() async throws {
        // Arrange: Item is openable, closed, and already touched
        let initialProperties: Set<ItemProperty> = [.container, .openable, .touched]
        let closedBox = Item(
            id: "box",
            name: "wooden box",
            parent: .location("startRoom")
        )
        closedBox.properties = initialProperties

        let game = MinimalGame(items: [closedBox])
        let mockIO = await MockIOHandler()
        let mockParser = MockParser()
        let engine = GameEngine(
            game: game,
            parser: mockParser,
            ioHandler: mockIO
        )

        // Initial state check
        #expect(engine.itemSnapshot(with: "box")?.hasProperty(.open) == false)
        #expect(engine.itemSnapshot(with: "box")?.hasProperty(.touched) == true)
        #expect(engine.gameState.changeHistory.isEmpty == true)

        let command = Command(verbID: "open", directObject: "box", rawInput: "open box")

        // Act: Call the engine's execute method
        await engine.execute(command: command)

        // Assert State Change
        let finalItemState = engine.itemSnapshot(with: "box")
        let expectedProperties: Set<ItemProperty> = [.container, .openable, .open, .touched]
        #expect(finalItemState?.properties == expectedProperties, "Item should gain .open property and retain .touched")

        // Assert Output
        let output = await mockIO.flush()
        expectNoDifference(output, "You open the wooden box.")

        // Assert Change History
        #expect(engine.gameState.changeHistory.count == 1)
        let recordedChange = engine.gameState.changeHistory.first
        let expectedChange = StateChange(
            entityId: .item("box"),
            propertyKey: .itemProperties,
            oldValue: .itemProperties(initialProperties),
            newValue: .itemProperties(expectedProperties)
        )
        // Change should still happen because .open is added
        expectNoDifference(recordedChange, expectedChange)
    }

    @Test("Open fails with no direct object")
    func testOpenFailsWithNoObject() async throws {
        // Arrange
        let game = MinimalGame()
        let mockIO = await MockIOHandler()
        let mockParser = MockParser()
        let engine = GameEngine(
            game: game,
            parser: mockParser,
            ioHandler: mockIO
        )
        let command = Command(verbID: "open", rawInput: "open")

        // Act & Assert: Expect error from validate()
        await #expect(throws: ActionError.prerequisiteNotMet("Open what?")) {
             try await handler.perform(command: command, engine: engine)
        }
        // Verify no output was generated by handler itself
        #expect(await mockIO.recordedOutput.isEmpty == true)
    }

    @Test("Open fails item not accessible")
    func testOpenFailsItemNotAccessible() async throws {
        // Arrange
        let box = Item(id: "box", name: "box", properties: .openable, parent: .nowhere)
        let game = MinimalGame(items: [box])
        let mockIO = await MockIOHandler()
        let mockParser = MockParser()
        let engine = GameEngine(game: game, parser: mockParser, ioHandler: mockIO)
        let command = Command(verbID: "open", directObject: "box", rawInput: "open box")

        // Act & Assert
        await #expect(throws: ActionError.itemNotAccessible("box")) {
            try await handler.perform(command: command, engine: engine)
        }
    }

    @Test("Open fails item not openable")
    func testOpenFailsItemNotOpenable() async throws {
        // Arrange
        let rock = Item(
            id: "rock",
            name: "heavy rock",
            parent: .location("startRoom")
        ) // No .openable

        let game = MinimalGame(items: [rock])
        let mockIO = await MockIOHandler()
        let mockParser = MockParser()
        let engine = GameEngine(
            game: game,
            parser: mockParser,
            ioHandler: mockIO
        )

        let command = Command(verbID: "open", directObject: "rock", rawInput: "open rock")

        // Act & Assert: Expect error from validate()
        await #expect(throws: ActionError.itemNotOpenable("rock")) {
            try await handler.perform(command: command, engine: engine)
        }
    }

    @Test("Open fails item already open")
    func testOpenFailsItemAlreadyOpen() async throws {
        // Arrange
        let openBox = Item(
            id: "box",
            name: "wooden box",
            properties: .container, .openable, .open, // Starts open
            parent: .location("startRoom")
        )

        let game = MinimalGame(items: [openBox])
        let mockIO = await MockIOHandler()
        let mockParser = MockParser()
        let engine = GameEngine(
            game: game,
            parser: mockParser,
            ioHandler: mockIO
        )

        let command = Command(verbID: "open", directObject: "box", rawInput: "open box")

        // Act & Assert: Expect error from validate()
        await #expect(throws: ActionError.itemAlreadyOpen("box")) {
            try await handler.perform(command: command, engine: engine)
        }
    }

    @Test("Open fails item is locked")
    func testOpenFailsItemIsLocked() async throws {
        // Arrange
        let lockedChest = Item(
            id: "chest",
            name: "iron chest",
            properties: .container, .openable, .locked,
            parent: .location("startRoom")
        ) // Locked

        let game = MinimalGame(items: [lockedChest])
        let mockIO = await MockIOHandler()
        let mockParser = MockParser()
        let engine = GameEngine(
            game: game,
            parser: mockParser,
            ioHandler: mockIO
        )

        let command = Command(verbID: "open", directObject: "chest", rawInput: "open chest")

        // Act & Assert: Expect error from validate()
        await #expect(throws: ActionError.itemIsLocked("chest")) {
            try await handler.perform(command: command, engine: engine)
        }
    }
}
