{"seeAlsoSections":[{"identifiers":["doc:\/\/GnustoEngine\/documentation\/GnustoEngine\/FAQs"],"anchor":"Further-Reading","title":"Further Reading","generated":true}],"hierarchy":{"paths":[["doc:\/\/GnustoEngine\/documentation\/GnustoEngine"]]},"variants":[{"paths":["\/documentation\/gnustoengine\/actionhandlerguide"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"article","sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine\/ActionHandlerGuide"},"metadata":{"modules":[{"name":"GnustoEngine"}],"role":"article","title":"Action Handler Development Guide","roleHeading":"Article"},"abstract":[{"type":"text","text":"Action handlers are the core components that process player commands in the Gnusto Interactive Fiction Engine. With 80+ built-in handlers covering everything from basic interactions to combat, conversations, and complex puzzle mechanics, this guide covers the design principles, implementation patterns, and best practices for creating effective action handlers that work with the modern proxy-based architecture."}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","anchor":"Overview","type":"heading"},{"inlineContent":[{"type":"text","text":"Action handlers translate player intent into game responses and state changes. They follow a careful scoring system that selects the most appropriate handler for each command, ensuring players receive contextually relevant feedback."}],"type":"paragraph"},{"level":3,"text":"Core Responsibilities","anchor":"Core-Responsibilities","type":"heading"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Parse player commands","type":"text"}],"type":"strong"},{"text":" using syntax rules and verb matching","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Validate prerequisites","type":"text"}],"type":"strong"},{"text":" (reachability, game state, etc.)","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Generate meaningful responses","type":"text"}],"type":"strong"},{"type":"text","text":" that keep players engaged"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Apply minimal state changes"}]},{"type":"text","text":" through the StateChange pipeline"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Update pronouns and context","type":"text"}]},{"type":"text","text":" for natural language flow"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":2,"text":"Design Philosophy","anchor":"Design-Philosophy","type":"heading"},{"level":3,"text":"Keep It Simple","anchor":"Keep-It-Simple","type":"heading"},{"inlineContent":[{"type":"text","text":"Action handlers should provide plausible responses without over-engineering game-specific logic:"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ ✅ Good: Generic, reusable","if !targetItem.hasFlag(.isTakeable) {","    throw ActionResponse.itemNotTakable(targetItem.name)","}","","\/\/ ❌ Avoid: Game-specific logic in engine","if targetItem.hasFlag(.isSponge) && !player.hasFlag(.hasWetHands) {","    throw await ActionResponse.feedback(\"The sponge is too dry to pick up.\")","}","","\/\/ ❌ Bad: Name or description based matching","if targetItem.name.contains(\"sand\") {","    throw await ActionResponse.feedback(\"The sand slips through your fingers.\")","}"],"type":"codeListing"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Principle","type":"text"}]},{"type":"text","text":": The engine provides building blocks; game developers add specificity by overriding default behavior."}],"type":"paragraph"},{"level":3,"text":"State Changes Flow Through Pipeline","anchor":"State-Changes-Flow-Through-Pipeline","type":"heading"},{"inlineContent":[{"type":"text","text":"All game state modifications must use the "},{"type":"codeVoice","code":"StateChange"},{"type":"text","text":" system. Action handlers return an "},{"type":"codeVoice","code":"ActionResult"},{"type":"text","text":", which includes a player-facing message and any changes to the game state."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ ✅ Correct: Using StateChange pipeline","public func process(context: ActionContext) async throws -> ActionResult {","    \/\/ Process inbound command, validate correctness...","","    return await ActionResult(","        message,","        item.setFlag(.isTouched),","        item.clearFlag(.isInflated)","    )","}"],"type":"codeListing"},{"level":3,"text":"Use MessageProvider for ActionHandler Responses","anchor":"Use-MessageProvider-for-ActionHandler-Responses","type":"heading"},{"inlineContent":[{"text":"Never hardcode ","type":"text"},{"type":"codeVoice","code":"ActionHandler"},{"text":" response text. Always use the ","type":"text"},{"type":"codeVoice","code":"Messenger"},{"text":" system (via ","type":"text"},{"type":"codeVoice","code":"context.msg"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"engine.messenger"},{"text":") for consistency and localization:","type":"text"}],"type":"paragraph"},{"code":["\/\/ ✅ Good: Using Messenger system","throw await ActionResponse.feedback(","    context.msg.itemNotTakable(item.withDefiniteArticle)",")","","\/\/ ❌ Bad: Hardcoded text","throw await ActionResponse.feedback(\"You can't take that!\")"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Messenger"},{"type":"text","text":" system contains default responses for a wide variety of commands. Game developers can subclass "},{"type":"codeVoice","code":"MessageProvider"},{"type":"text","text":" to replace the default responses as needed to fit their own game’s language and tone, and the engine automatically uses their custom messenger throughout all interactions."}],"type":"paragraph"},{"text":"Action Handler Structure","level":2,"type":"heading","anchor":"Action-Handler-Structure"},{"text":"Basic Implementation","level":3,"type":"heading","anchor":"Basic-Implementation"},{"code":["public struct ExampleActionHandler: ActionHandler {","    public let syntax: [SyntaxRule] = [","        .match(.verb, .directObject),","        .match(.pick, .up, .directObject)","    ]","","    public let synonyms: [Verb] = [.take, .get, .grab]","","    public let requiresLight: Bool = true","","    public func process(context: ActionContext) async throws -> ActionResult {","        \/\/ Implementation details...","    }","}"],"type":"codeListing","syntax":"swift"},{"text":"Syntax Rules and the Synonyms Property","level":3,"type":"heading","anchor":"Syntax-Rules-and-the-Synonyms-Property"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"synonyms","type":"codeVoice"},{"text":" property contains verb synonyms that match any ","type":"text"},{"code":".verb","type":"codeVoice"},{"text":" tokens in syntax rules.","type":"text"}],"type":"paragraph"},{"code":["public let syntax: [SyntaxRule] = [","    .match(.verb, .directObject),      \/\/ `.verb` is generic","    .match(.pick, .up, .directObject)  \/\/ `.pick` is specific","]","","public let synonyms: [Verb] = [.take, .get, .grab]  \/\/ Match the generic `.verb` token"],"type":"codeListing","syntax":"swift"},{"header":"row","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅ Matching Commands"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌ Non-matching Commands"}]}]],[[{"type":"paragraph","inlineContent":[{"code":"TAKE SWORD","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"TAKE UP SWORD"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"GET SWORD"}]}],[{"type":"paragraph","inlineContent":[{"code":"PICK SWORD","type":"codeVoice"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"GRAB SWORD"}]}],[{"type":"paragraph","inlineContent":[]}]],[[{"type":"paragraph","inlineContent":[{"code":"PICK UP SWORD","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[]}]]],"type":"table"},{"text":"Action Processing Patterns","level":3,"type":"heading","anchor":"Action-Processing-Patterns"},{"inlineContent":[{"text":"Real action handlers follow much simpler patterns than you might expect, but now work through the proxy system for safe state access. Here are the most common patterns from actual handlers:","type":"text"}],"type":"paragraph"},{"text":"Pattern 1: Simple Object Action (like BlowActionHandler)","level":4,"type":"heading","anchor":"Pattern-1-Simple-Object-Action-like-BlowActionHandler"},{"code":["public func process(context: ActionContext) async throws -> ActionResult {","    guard let targetItemID = context.command.directObjectItemID else {","        \/\/ Handle no-object case","        return ActionResult(context.msg.blow())","    }","","    guard await context.engine.playerCanReach(targetItemID) else {","        throw ActionResponse.itemNotAccessible(targetItemID)","    }","","    let targetItem = await context.item(targetItemID)","","    return await ActionResult(","        context.msg.blowOn(item: targetItem.withDefiniteArticle),","        targetItem.setFlag(.isTouched)","    )","}"],"type":"codeListing","syntax":"swift"},{"text":"Pattern 2: Character Interaction (like AskActionHandler)","level":4,"type":"heading","anchor":"Pattern-2-Character-Interaction-like-AskActionHandler"},{"code":["public func process(context: ActionContext) async throws -> ActionResult {","    guard let characterID = context.command.directObjectItemID else {","        throw await ActionResponse.feedback(context.msg.askWhom())","    }","","    let character = await context.item(characterID)","","    guard await character.isCharacter else {","        throw await ActionResponse.feedback(","            context.msg.cannotAskAboutThat(item: character.withDefiniteArticle)","        )","    }","","    guard await context.engine.playerCanReach(characterID) else {","        throw ActionResponse.itemNotAccessible(characterID)","    }","","    \/\/ Handle different scenarios based on command structure","    if let topic = context.command.indirectObject {","        return try await processDirectAsk(character: character, topic: topic, context: context)","    } else {","        return await promptForTopic(character: character, context: context)","    }","}"],"type":"codeListing","syntax":"swift"},{"text":"Pattern 3: Combat Action (like AttackActionHandler)","level":4,"type":"heading","anchor":"Pattern-3-Combat-Action-like-AttackActionHandler"},{"code":["public func process(context: ActionContext) async throws -> ActionResult {","    guard let targetItemID = context.command.directObjectItemID else {","        throw await ActionResponse.feedback(context.msg.doWhat(context.command.verb))","    }","","    let targetItem = await context.item(targetItemID)","","    guard await context.engine.playerCanReach(targetItemID) else {","        throw ActionResponse.itemNotAccessible(targetItemID)","    }","","    \/\/ Different responses based on target and weapon","    let message: String","    if !await targetItem.isCharacter {","        message = context.msg.attackNonCharacter(item: targetItem.withDefiniteArticle)","    } else if context.command.indirectObject == nil {","        message = context.msg.attackWithBareHands(character: targetItem.withDefiniteArticle)","    } else {","        \/\/ Handle weapon attacks - may trigger combat system","        return try await handleCombatAttack(target: targetItem, context: context)","    }","","    return ActionResult(","        message,","        targetItem.setFlag(.isTouched),","        await context.engine.updatePronouns(to: targetItem)","    )","}"],"type":"codeListing","syntax":"swift"},{"text":"Pattern 4: Optional Objects (like BreatheActionHandler)","level":4,"type":"heading","anchor":"Pattern-4-Optional-Objects-like-BreatheActionHandler"},{"code":["public func process(context: ActionContext) async throws -> ActionResult {","    guard let targetItemID = context.command.directObjectItemID else {","        \/\/ No object - general action","        return ActionResult(context.msg.breatheResponse())","    }","","    \/\/ Object specified - targeted action","    let targetItem = await context.item(targetItemID)","","    guard await context.engine.playerCanReach(targetItemID) else {","        throw ActionResponse.itemNotAccessible(targetItemID)","    }","","    return ActionResult(","        context.msg.breatheOnResponse(item: targetItem.withDefiniteArticle),","        targetItem.setFlag(.isTouched),","        await context.engine.updatePronouns(to: targetItem)","    )","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"inlineContent":[{"text":"Key Insights from Real Handlers:","type":"text"}],"type":"strong"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Most handlers are much simpler than you might expect"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Common pattern: validate → get item proxy → check accessibility → generate response"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"State changes are minimal: usually just ","type":"text"},{"type":"codeVoice","code":".isTouched"},{"text":" and pronoun updates","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Complex logic is often just conditional responses, not complex state manipulation","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The proxy system provides safe, concurrent access to both static and computed properties","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Combat and conversation handlers may delegate to specialized subsystems","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"ActionResult constructor accepts variadic StateChange arguments for convenience"}],"type":"paragraph"}]}]},{"text":"Universal Object Handling","level":2,"type":"heading","anchor":"Universal-Object-Handling"},{"inlineContent":[{"text":"Universal objects represent concepts like “sky”, “ground”, “walls” that are implicitly present but don’t need explicit ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" objects. Players should receive a reasonable response when they try to interact with these: “LOOK AT THE SKY”, “DIG THE GROUND”, “TOUCH THE WALLS”.","type":"text"}],"type":"paragraph"},{"text":"Supporting Universal Objects","level":3,"type":"heading","anchor":"Supporting-Universal-Objects"},{"inlineContent":[{"text":"Action handlers can support universal objects during normal processing:","type":"text"}],"type":"paragraph"},{"code":["public struct ExamineActionHandler: ActionHandler {","    \/\/ ... other properties ...","","    public func process(context: ActionContext) async throws -> ActionResult {","        \/\/ Handle both items and universals","        for directObjectRef in context.command.directObjects {","            switch directObjectRef {","            case .item(let itemID):","                \/\/ Handle regular items through proxy system","                let item = await context.item(itemID)","","            case .universal(let universal):","                \/\/ Handle universals like .sky, .ground, .walls","                return ActionResult(","                    context.msg.nothingSpecialAbout(universal.displayName)","                )","","            default:","                \/\/ Handle other types...","            }","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"text":"Universal Object Patterns","level":3,"type":"heading","anchor":"Universal-Object-Patterns"},{"code":["\/\/ Digging handler that works with ground\/earth universals","Universal.diggableUniversals.contains(universal)","","\/\/ Movement handler that only works with architectural features","Universal.architecturalUniversals.contains(universal)"],"type":"codeListing","syntax":"swift"},{"text":"Universal Object Categories","level":3,"type":"heading","anchor":"Universal-Object-Categories"},{"inlineContent":[{"text":"Universal objects are pre-categorized for convenience:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"Universal.diggableUniversals"},{"type":"text","text":": ground, earth, soil, dirt, mud, sand"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Universal.waterUniversals"},{"type":"text","text":": water, river, stream, lake, pond, ocean, sea"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"Universal.architecturalUniversals"},{"type":"text","text":": floor, walls, wall, ceiling, roof"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Universal.outdoorUniversals"},{"type":"text","text":": sky, sun, moon, stars, clouds, etc."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Universal.indoorUniversals"},{"text":": ceiling, walls, floor, etc.","type":"text"}]}]}]},{"inlineContent":[{"text":"This system ensures players get reasonable responses to common interactions without requiring game developers to create explicit items for every possible universal concept.","type":"text"}],"type":"paragraph"},{"text":"Handler Selection and Scoring","level":2,"type":"heading","anchor":"Handler-Selection-and-Scoring"},{"inlineContent":[{"type":"text","text":"The engine uses a sophisticated scoring system to select the most appropriate handler:"}],"type":"paragraph"},{"text":"Scoring Hierarchy","level":3,"type":"heading","anchor":"Scoring-Hierarchy"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"0","type":"text"}]},{"type":"text","text":": No match (handler cannot process command)"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"100-199","type":"text"}],"type":"strong"},{"type":"text","text":": Basic verb match"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"200-299"}],"type":"strong"},{"text":": Specific verb match","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"+10"}]},{"type":"text","text":": Required objects present"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"+20"}]},{"type":"text","text":": Required particles match"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"+5","type":"text"}],"type":"strong"},{"text":": Handler has syntax rules","type":"text"}],"type":"paragraph"}]}]},{"text":"Example Scoring","level":3,"type":"heading","anchor":"Example-Scoring"},{"code":["Command: `TURN ON LAMP`","","TurnHandler   .match(.verb, .directObject):       Score: 115","TurnOnHandler .match(.turn, .on, .directObject):  Score: 235 ✅","","Result: TurnOnHandler chosen (more specific)"],"type":"codeListing","syntax":null},{"inlineContent":[{"type":"text","text":"This scoring system ensures the most appropriate handler is always selected."}],"type":"paragraph"},{"text":"Testing Requirements","level":2,"type":"heading","anchor":"Testing-Requirements"},{"inlineContent":[{"text":"Action handlers require comprehensive test coverage (80-90%) using Swift Testing.","type":"text"}],"type":"paragraph"},{"text":"Essential Test Categories","level":3,"type":"heading","anchor":"Essential-Test-Categories"},{"text":"1. Syntax Rule Testing","level":4,"type":"heading","anchor":"1-Syntax-Rule-Testing"},{"inlineContent":[{"text":"Test every supported pattern and verify unsupported patterns fail:","type":"text"}],"type":"paragraph"},{"code":["@Test(\"TAKE syntax works\")","func testTakeSyntax() async throws {","    let testRoom = Location(.startRoom)","        .name(\"Test Room\")","        .inherentlyLit","","    let testItem = Item(\"lamp\")","        .name(\"brass lamp\")","        .isTakable","        .in(.startRoom)","","    let game = MinimalGame(","        player: Player(in: .startRoom),","        locations: testRoom,","        items: testItem","    )","","    let (engine, mockIO) = await GameEngine.test(blueprint: game)","","    try await engine.execute(\"take lamp\")","","    await mockIO.expect(","        \"\"\"","        > take lamp","        Taken.","        \"\"\"","    )","}","","@Test(\"Invalid syntax patterns are rejected\")","func testInvalidSyntax() async throws {","    \/\/ Test patterns not in syntax rules","}"],"type":"codeListing","syntax":"swift"},{"text":"2. Validation Testing","level":4,"type":"heading","anchor":"2-Validation-Testing"},{"inlineContent":[{"type":"text","text":"Test all prerequisite checks:"}],"type":"paragraph"},{"code":["@Test(\"Requires item to be takeable\")","func testRequiresTakeable() async throws {","    \/\/ Setup: Non-takeable item","    \/\/ When: Try to take it","    \/\/ Then: Should fail with appropriate message","}"],"type":"codeListing","syntax":"swift"},{"text":"3. State Change Testing","level":4,"type":"heading","anchor":"3-State-Change-Testing"},{"inlineContent":[{"type":"text","text":"Verify successful actions produce expected state changes:"}],"type":"paragraph"},{"code":["@Test(\"Take moves item to player\")","func testTakeMovesItem() async throws {","    let (engine, mockIO) = await GameEngine.test(blueprint: game)","","    try await engine.execute(\"take lamp\")","","    let finalState = await engine.item(\"lamp\")","    #expect(await finalState.playerIsHolding)","}"],"type":"codeListing","syntax":"swift"},{"text":"Critical Testing Principles","level":3,"type":"heading","anchor":"Critical-Testing-Principles"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Always test through the full engine pipeline!","type":"text"}]}],"type":"paragraph"},{"code":["\/\/ ✅ RIGHT: Test complete flow through parser and action system","try await engine.execute(\"take lamp\")","","\/\/ ❌ WRONG: Skip parser (misses real bugs)","let command = Command(verb: .take, directObject: \"lamp\", rawInput: \"take lamp\")","try await handler.process(context: ActionContext(command: command, engine: engine))"],"type":"codeListing","syntax":"swift"},{"text":"Standard Test Setup","level":3,"type":"heading","anchor":"Standard-Test-Setup"},{"code":["@Test(\"Test description\")","func testSomething() async throws {","    \/\/ Given: Complete game setup","    let testRoom = Location(\"testRoom\")","        .name(\"Test Room\")","        .inherentlyLit","","    let testItem = Item(\"testItem\")","        .name(\"test item\")","        .isTakable","        .in(.startRoom)","","    let game = MinimalGame(","        player: Player(in: .startRoom),","        locations: testRoom,","        items: testItem","    )","","    let (engine, mockIO) = await GameEngine.test(blueprint: game)","","    \/\/ When: Execute through full pipeline","    try await engine.execute(\"take test item\")","","    \/\/ Then: Verify results","    await mockIO.expect(","        \"\"\"","        > take test item","        Taken.","        \"\"\"","    )","","    let finalState = await engine.item(\"testItem\")","    #expect(await finalState.parent == .player)","}"],"type":"codeListing","syntax":"swift"},{"text":"Common Patterns","level":2,"type":"heading","anchor":"Common-Patterns"},{"text":"Handling ALL Commands","level":3,"type":"heading","anchor":"Handling-ALL-Commands"},{"code":["if context.command.isAllCommand {","    \/\/ Skip problematic items, don't throw errors","    guard await context.engine.playerCanReach(itemID) else {","        continue","    }","","    \/\/ Provide summary message if nothing processed","    if processedItems.isEmpty {","        return ActionResult(","            context.msg.nothingHereToTake()","        )","    }","}"],"type":"codeListing","syntax":"swift"},{"text":"Preposition Delegation","level":3,"type":"heading","anchor":"Preposition-Delegation"},{"code":["\/\/ Delegate to specialized handlers for prepositional variants","if context.hasPreposition(.in, .on) {","    let lookInsideHandler = LookInsideActionHandler()","    return try await lookInsideHandler.process(context: context)","}"],"type":"codeListing","syntax":"swift"},{"text":"Multiple Object Processing","level":3,"type":"heading","anchor":"Multiple-Object-Processing"},{"code":["var processedItems: [ItemProxy] = []","","for directObjectRef in context.command.directObjects {","    \/\/ Process each object through proxy system...","    processedItems.append(item)","}"],"type":"codeListing","syntax":"swift"},{"text":"Best Practices","level":2,"type":"heading","anchor":"Best-Practices"},{"text":"Do’s","level":3,"type":"heading","anchor":"Dos"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅ Use specific verbs in syntax rules when possible"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"✅ Test through the complete engine pipeline","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅ Keep validation logic generic and reusable"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"✅ Use Messenger system (context.msg) for all responses"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"✅ Handle ALL commands gracefully","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"✅ Update pronouns after processing","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅ Flow state changes through StateChange pipeline via proxy system"}]}]}]},{"text":"Don’ts","level":3,"type":"heading","anchor":"Donts"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"❌ Don’t hardcode response text","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"❌ Don’t bypass the parser in tests","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌ Don’t put game-specific logic in engine handlers"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌ Don’t forget to handle edge cases (empty input, unreachable items)"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"❌ Don’t use "},{"code":".contains()","type":"codeVoice"},{"type":"text","text":" for message testing"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"❌ Don’t modify game state directly","type":"text"}]}]}]},{"text":"Message Testing Best Practices","level":3,"type":"heading","anchor":"Message-Testing-Best-Practices"},{"code":["\/\/ ✅ RIGHT: Exact message matching with command echo","await mockIO.expect(","    \"\"\"","    > take lamp","    Taken.","    \"\"\"",")","","\/\/ ❌ WRONG: Partial matching","#expect(output.contains(\"Taken\"))","","\/\/ ❌ WRONG: Missing command echo","expectNoDifference(output, \"Taken.\")"],"type":"codeListing","syntax":"swift"},{"text":"Advanced Topics","level":2,"type":"heading","anchor":"Advanced-Topics"},{"text":"Custom Question Handling","level":3,"type":"heading","anchor":"Custom-Question-Handling"},{"inlineContent":[{"text":"For handlers that need to ask follow-up questions:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Two-phase asking pattern integrated with conversation system","if context.command.indirectObject == nil {","    let prompt = \"What do you want to ask \\(character.withDefiniteArticle) about?\"","","    let questionChanges = await ConversationManager.askForTopic(","        prompt: prompt,","        characterID: characterID,","        originalCommand: context.command,","        context: context","    )","","    return ActionResult(message: prompt, changes: questionChanges)","}"],"type":"codeListing","syntax":"swift"},{"text":"Handler Specialization","level":3,"type":"heading","anchor":"Handler-Specialization"},{"inlineContent":[{"text":"Create specialized handlers for complex scenarios:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Generic handler for most cases","public struct TakeActionHandler: ActionHandler { ... }","","\/\/ Specialized handler for specific game mechanics","public struct TakeFromContainerActionHandler: ActionHandler {","    public let syntax: [SyntaxRule] = [","        .match(.take, .directObject, .from, .indirectObject)","    ]","    \/\/ Specialized logic for container interactions","}"],"type":"codeListing","syntax":"swift"},{"text":"Item Event Handlers","level":3,"type":"heading","anchor":"Item-Event-Handlers"},{"inlineContent":[{"text":"For item-specific behavior, use ItemEventHandlers with the proxy system:","type":"text"}],"type":"paragraph"},{"code":["\/\/ In game code, not engine","let lampHandler = ItemEventHandler(for: .magicLamp) {","    before(.examine) { context, command in","        \/\/ Custom examine behavior for magic lamp with proxy access","        let lamp = await context.item(.magicLamp)","        let glowLevel = await lamp.property(\"glowLevel\", type: Int.self) ?? 0","","        let message = glowLevel > 0 ?","            \"The lamp glows with inner light...\" :","            \"The lamp appears ordinary.\"","","        return ActionResult(message)","    }","}"],"type":"codeListing","syntax":"swift"},{"text":"Integration with Engine","level":2,"type":"heading","anchor":"Integration-with-Engine"},{"text":"Handler Registration","level":3,"type":"heading","anchor":"Handler-Registration"},{"inlineContent":[{"type":"text","text":"Handlers are automatically discovered and registered:"}],"type":"paragraph"},{"code":["\/\/ Engine automatically finds and registers handlers","public static let defaultActionHandlers: [ActionHandler] = [","    TakeActionHandler(),","    ExamineActionHandler(),","    \/\/ ... other handlers","]"],"type":"codeListing","syntax":"swift"},{"text":"Vocabulary Integration","level":3,"type":"heading","anchor":"Vocabulary-Integration"},{"inlineContent":[{"type":"text","text":"The engine automatically extracts verbs from handlers for vocabulary registration:"}],"type":"paragraph"},{"code":["\/\/ Both explicit verbs and syntax-embedded verbs are registered","public let synonyms: [Verb] = [.grab]              \/\/ Explicit","public let syntax: [SyntaxRule] = [","    .match(.take, .directObject)                \/\/ .take auto-registered","]"],"type":"codeListing","syntax":"swift"},{"text":"Contributing to the Engine","level":2,"type":"heading","anchor":"Contributing-to-the-Engine"},{"inlineContent":[{"text":"When contributing action handlers to the engine:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Keep them generic"}]},{"type":"text","text":" - avoid game-specific logic"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Comprehensive testing","type":"text"}],"type":"strong"},{"text":" - 80-90% coverage required","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Follow established patterns"}]},{"type":"text","text":" - consistent with existing handlers"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Document thoroughly"}]},{"type":"text","text":" - clear inline documentation"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Consider backward compatibility"}],"type":"strong"},{"text":" - don’t break existing games","type":"text"}],"type":"paragraph"}]}]},{"text":"Pull Request Requirements","level":3,"type":"heading","anchor":"Pull-Request-Requirements"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"All tests pass with high coverage","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Follows established code style"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Includes comprehensive test suite"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Documents any breaking changes"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Provides clear examples of usage"}],"type":"paragraph"}]}]},{"text":"Summary","level":2,"type":"heading","anchor":"Summary"},{"inlineContent":[{"text":"Action handlers are the bridge between player intent and game response. By following these principles–keeping logic generic, using the StateChange pipeline, testing comprehensively, and providing engaging responses–you’ll create handlers that enhance the interactive fiction experience while maintaining clean, maintainable code.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The Gnusto engine’s sophisticated handler selection system ensures that the most appropriate handler is always chosen, allowing developers to create both broad, generic handlers and specialized, context-specific ones that work together seamlessly."}],"type":"paragraph"}]}],"references":{"doc://GnustoEngine/documentation/GnustoEngine/FAQs":{"abstract":[{"text":"Quick answers to common questions about the Gnusto Interactive Fiction Engine.","type":"text"}],"title":"Frequently Asked Questions","type":"topic","url":"\/documentation\/gnustoengine\/faqs","kind":"article","role":"article","identifier":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine\/FAQs"},"doc://GnustoEngine/documentation/GnustoEngine":{"abstract":[],"kind":"symbol","role":"collection","url":"\/documentation\/gnustoengine","title":"GnustoEngine","identifier":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine","type":"topic"}}}