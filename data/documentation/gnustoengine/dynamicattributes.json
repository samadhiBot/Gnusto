{"primaryContentSections":[{"content":[{"text":"Overview","type":"heading","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Gnusto Engine’s dynamic attribute system allows you to create attributes that are computed at runtime or validated when changed. This enables complex game mechanics similar to those found in classic ZIL-based interactive fiction games like Zork."}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Note","type":"text"}],"type":"strong"},{"type":"text","text":": If you’re using the GnustoAutoWiringPlugin, dynamic attribute registrations in your code (like "},{"code":"registerItemCompute(itemID: .sword, attribute: .sharpness)","type":"codeVoice"},{"text":") are automatically discovered and set up for you. You can focus on writing the logic while the plugin handles the wiring.","type":"text"}],"type":"paragraph"}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Important"}]},{"text":": All attribute changes must flow through the action pipeline using ","type":"text"},{"code":"StateChange","type":"codeVoice"},{"type":"text","text":" builders. This ensures proper validation, event handling, and consistency."}],"type":"paragraph"},{"type":"heading","anchor":"Basic-Usage","text":"Basic Usage","level":2},{"text":"Reading Attributes","anchor":"Reading-Attributes","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the fetch methods to read dynamic or static attributes:"}]},{"code":["\/\/ Fetch typed values","let sharpness: Int = try await engine.attribute(\"sharpness\", of .sword)","let description: String = try await engine.attribute(.description, of .sword)","let isOpen: Bool = try await engine.attribute(.isOpen, of .door)","","\/\/ Fetch location attributes","let temperature: String = try await engine.attribute(\"temperature\", of .cave)"],"syntax":"swift","type":"codeListing"},{"text":"Setting Attributes (Respecting the Pipeline)","type":"heading","level":3,"anchor":"Setting-Attributes-Respecting-the-Pipeline"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Always use "},{"code":"StateChange","type":"codeVoice"},{"type":"text","text":" builders"}]},{"type":"text","text":" to modify attributes. Never bypass the action pipeline:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Create StateChange using builders","let item = try engine.item(\"sword\")","if let change = await engine.setAttribute(\"sharpness\", on: item, to: .int(8)) {","    \/\/ Apply through the pipeline (usually in an ActionHandler)","    return ActionResult(stateChanges: [change], message: \"The sword gleams with sharpness.\")","}","","\/\/ Use convenience builders for common patterns","if let change = await engine.setDescription(on: item, to: \"A gleaming blade\") {","    return ActionResult(stateChanges: [change])","}","","if let change = await engine.setAttribute(\"isOpen\", on: door, to: true) {","    return ActionResult(stateChanges: [change], message: \"The door swings open.\")","}"]},{"type":"heading","text":"Validation Handlers","anchor":"Validation-Handlers","level":2},{"type":"paragraph","inlineContent":[{"text":"Validation handlers allow you to enforce rules when attributes are changed, similar to ZIL’s property validation. They are called automatically when ","type":"text"},{"code":"StateChange","type":"codeVoice"},{"text":"s are applied.","type":"text"}]},{"type":"heading","level":3,"text":"Basic Validation","anchor":"Basic-Validation"},{"type":"codeListing","syntax":"swift","code":["\/\/ Register a validation handler for a specific item and attribute","engine.registerItemValidate(itemID: \"door\", attributeID: \"isOpen\") { item, newValue in","    guard case .bool(let isOpening) = newValue else { return false }","","    \/\/ Can only open if not locked","    if isOpening {","        let isLocked = item.attributes[\"isLocked\"]?.toBool ?? false","        return !isLocked","    }","    return true","}"]},{"level":3,"anchor":"Complex-State-Management","type":"heading","text":"Complex State Management"},{"inlineContent":[{"text":"Inspired by Zork’s troll combat system:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Ensure troll state consistency when fighting status changes","engine.registerItemValidate(itemID: \"troll\", attributeID: \"fighting\") { item, newValue in","    guard case .bool(let isFighting) = newValue else { return false }","","    \/\/ If troll stops fighting, it must be unconscious or disarmed","    if !isFighting {","        let hasWeapon = item.attributes[\"hasWeapon\"]?.toBool ?? false","        let isUnconscious = item.attributes[\"unconscious\"]?.toBool ?? false","        return !hasWeapon || isUnconscious","    }","    return true","}"]},{"level":3,"text":"Throwing Specific Errors","anchor":"Throwing-Specific-Errors","type":"heading"},{"inlineContent":[{"text":"Validation handlers can throw specific errors for better user feedback:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["engine.registerItemValidate(itemID: \"magicSword\", attributeID: \"enchantmentLevel\") { item, newValue in","    guard case .int(let level) = newValue else {","        throw ActionResponse.prerequisiteNotMet(\"Enchantment level must be a number\")","    }","","    if level < 0 || level > 10 {","        throw ActionResponse.prerequisiteNotMet(\"Enchantment level must be between 0 and 10\")","    }","","    return true","}"]},{"anchor":"StateChange-Builders","text":"StateChange Builders","type":"heading","level":2},{"inlineContent":[{"text":"The engine provides convenient builders for creating ","type":"text"},{"code":"StateChange","type":"codeVoice"},{"type":"text","text":" objects that respect the action pipeline:"}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Generic-Attribute-Builders","text":"Generic Attribute Builders"},{"type":"codeListing","code":["\/\/ Set any StateValue on items or locations","let change = await engine.setAttribute(\"customProp\", on: item, to: .string(\"value\"))","let change = await engine.setAttribute(\"temperature\", on: location, to: .int(72))"],"syntax":"swift"},{"level":3,"anchor":"Convenience-Builders","text":"Convenience Builders","type":"heading"},{"code":["\/\/ Common patterns have dedicated builders","let change = await engine.setDescription(on: item, to: \"A new description\")","let change = await engine.setAttribute(\"isOpen\", on: door, to: true)","let change = await engine.setAttribute(\"isLit\", on: room, to: false)","let change = await engine.setAttribute(\"damage\", on: weapon, to: 15)","let change = await engine.setAttribute(\"material\", on: armor, to: \"steel\")"],"type":"codeListing","syntax":"swift"},{"anchor":"Using-StateChanges-in-Action-Handlers","level":3,"type":"heading","text":"Using StateChanges in Action Handlers"},{"code":["struct OpenActionHandler: ActionHandler {","    func process(context: ActionContext) async throws -> ActionResult {","        let item = try context.engine.item(context.command.directObjectID)","","        \/\/ Validate the item can be opened","        guard item.hasProperty(.isOpenable) else {","            throw ActionResponse.itemNotOpenable(item)","        }","","        \/\/ Create state change using builder","        guard let change = await context.engine.setAttribute(\"isOpen\", on: item, to: true) else {","            throw ActionResponse.itemAlreadyOpen(item)","        }","","        \/\/ Return result with state change - the engine will apply it through the pipeline","        return ActionResult(","            stateChanges: [change],","            message: \"You open \\(context.engine.theThat(item)).\"","        )","    }","}"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"ZIL-Inspired Patterns","type":"heading","anchor":"ZIL-Inspired-Patterns"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The dynamic attribute system enables classic interactive fiction patterns:"}]},{"level":3,"type":"heading","anchor":"Opening-and-Closing-Objects","text":"Opening and Closing Objects"},{"type":"codeListing","syntax":"swift","code":["\/\/ Similar to ZIL's FSET\/FCLEAR for OPENBIT","if let change = await engine.setAttribute(\"isOpen\", on: chest, to: true) {","    return ActionResult(stateChanges: [change], message: \"The chest creaks open.\")","}"]},{"type":"heading","anchor":"Dynamic-Descriptions","level":3,"text":"Dynamic Descriptions"},{"type":"codeListing","syntax":"swift","code":["\/\/ Similar to ZIL's PUTP for changing descriptions","let trollState = await engine.gameState.items[\"troll\"]?.attributes[\"fighting\"]?.toBool ?? false","let newDescription = if trollState {","    \"A nasty-looking troll, brandishing a bloody axe, blocks all passages.\"","} else {","    \"An unconscious troll is sprawled on the floor.\"","}","","if let change = await engine.setDescription(on: troll, to: newDescription) {","    return ActionResult(stateChanges: [change])","}"]},{"anchor":"State-Transitions","level":3,"type":"heading","text":"State Transitions"},{"syntax":"swift","code":["\/\/ Complex state changes with validation","let changes = [","    await engine.setAttribute(\"unconscious\", on: troll, to: true),","    await engine.setAttribute(\"fighting\", on: troll, to: false),","    await engine.setAttribute(\"isVisible\", on: axe, to: true)","].compactMap { $0 }","","return ActionResult(","    stateChanges: changes,","    message: \"The troll collapses, dropping his axe!\"",")"],"type":"codeListing"},{"type":"heading","text":"Best Practices","level":2,"anchor":"Best-Practices"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Always use StateChange builders"}]},{"type":"text","text":" instead of direct state mutation"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Return StateChanges in ActionResult"}],"type":"strong"},{"text":" to respect the action pipeline","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Use validation handlers","type":"text"}]},{"type":"text","text":" for complex state dependencies"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Throw specific errors","type":"text"}]},{"type":"text","text":" to provide clear feedback to players"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Use convenience methods"}]},{"type":"text","text":" for common patterns like flags and descriptions"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Register validators early","type":"text"}]},{"type":"text","text":" in your game setup, typically in the "},{"type":"codeVoice","code":"GameBlueprint"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Test edge cases","type":"text"}]},{"type":"text","text":" thoroughly, especially state transitions"}],"type":"paragraph"}]}],"type":"orderedList"},{"text":"Error Handling","type":"heading","anchor":"Error-Handling","level":2},{"type":"paragraph","inlineContent":[{"text":"The system throws ","type":"text"},{"type":"codeVoice","code":"ActionResponse"},{"type":"text","text":" errors for various failure conditions:"}]},{"items":[{"content":[{"inlineContent":[{"code":"ActionResponse.internalEngineError","type":"codeVoice"},{"type":"text","text":": Item or location doesn’t exist"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"ActionResponse.invalidValue","type":"codeVoice"},{"type":"text","text":": Validation failed (generic or from validation handlers)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Custom errors: Thrown by validation handlers for specific conditions","type":"text"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always handle these appropriately in your action handlers:"}]},{"syntax":"swift","type":"codeListing","code":["do {","    let result = try await someActionHandler.process(context: context)","    return result","} catch let response as ActionResponse {","    throw response \/\/ Re-throw ActionResponse for proper error reporting","} catch {","    throw ActionResponse.internalEngineError(\"Unexpected error: \\(error)\")","}"]},{"type":"heading","level":2,"anchor":"Integration-with-Action-Pipeline","text":"Integration with Action Pipeline"},{"type":"paragraph","inlineContent":[{"text":"The dynamic attribute system is fully integrated with the action pipeline:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Validation"}],"type":"strong"},{"text":": When ","type":"text"},{"type":"codeVoice","code":"StateChange"},{"type":"text","text":"s are applied, dynamic validation handlers are called automatically"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Event Handlers"}]},{"type":"text","text":": Item and location event handlers can create "},{"type":"codeVoice","code":"StateChange"},{"text":"s that trigger validation","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Consistency"}],"type":"strong"},{"type":"text","text":": All state mutations flow through the same validation and application process"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Debugging"}],"type":"strong"},{"type":"text","text":": All changes are tracked in "},{"code":"gameState.changeHistory","type":"codeVoice"},{"text":" for debugging","type":"text"}]}]}]},{"inlineContent":[{"type":"text","text":"This ensures that your game’s state remains consistent and that all business rules are enforced, regardless of how state changes are initiated."}],"type":"paragraph"}],"kind":"content"}],"metadata":{"role":"article","modules":[{"name":"GnustoEngine"}],"title":"Dynamic Attributes","roleHeading":"Article"},"identifier":{"url":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine\/DynamicAttributes","interfaceLanguage":"swift"},"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/GnustoEngine\/documentation\/GnustoEngine"]]},"kind":"article","sections":[],"abstract":[{"type":"text","text":"Learn how to use dynamic attributes and validation handlers to create sophisticated game mechanics while respecting the action pipeline."}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/gnustoengine\/dynamicattributes"]}],"references":{"doc://GnustoEngine/documentation/GnustoEngine":{"role":"collection","url":"\/documentation\/gnustoengine","abstract":[],"title":"GnustoEngine","identifier":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine","type":"topic","kind":"symbol"}}}