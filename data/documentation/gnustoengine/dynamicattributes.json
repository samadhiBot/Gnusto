{"variants":[{"paths":["\/documentation\/gnustoengine\/dynamicattributes"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/GnustoEngine\/documentation\/GnustoEngine"]]},"sections":[],"metadata":{"modules":[{"name":"GnustoEngine"}],"role":"article","title":"Dynamic Properties and Proxy System","roleHeading":"Article"},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"The Gnusto Engine’s proxy system provides safe, concurrent access to game state while enabling both static and dynamic properties. Instead of accessing game objects directly, you work with proxy objects (","type":"text"},{"code":"ItemProxy","type":"codeVoice"},{"text":", ","type":"text"},{"code":"LocationProxy","type":"codeVoice"},{"text":", ","type":"text"},{"code":"PlayerProxy","type":"codeVoice"},{"text":") that automatically handle state computation, validation, and safe concurrent access.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The proxy system enables complex game mechanics similar to those found in classic ZIL-based interactive fiction games like Zork, while maintaining Swift 6 concurrency safety and modern architectural patterns.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Compute handlers can be defined in your ","type":"text"},{"code":"GameBlueprint","type":"codeVoice"},{"text":" using the ","type":"text"},{"code":"itemComputeHandlers","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"locationComputeHandlers","type":"codeVoice"},{"text":" properties, or registered at runtime for more dynamic scenarios.","type":"text"}]},{"style":"note","type":"aside","content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Note","type":"text"}]},{"type":"text","text":": If you’re using the GnustoAutoWiringPlugin, it will generate helpful scaffolding for the GameBlueprint approach, including commented examples for your items and locations."}],"type":"paragraph"}],"name":"Note"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Important"}],"type":"strong"},{"type":"text","text":": All property changes must flow through the action pipeline using "},{"type":"codeVoice","code":"StateChange"},{"type":"text","text":" builders accessed through proxy objects. This ensures proper validation, event handling, and consistency while maintaining concurrency safety."}]},{"type":"heading","level":2,"text":"Proxy System Fundamentals","anchor":"Proxy-System-Fundamentals"},{"type":"heading","level":3,"text":"Understanding Proxies","anchor":"Understanding-Proxies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of working with "},{"type":"codeVoice","code":"Item"},{"type":"text","text":", "},{"type":"codeVoice","code":"Location"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Player"},{"type":"text","text":" objects directly, you access them through proxy objects that provide safe, concurrent access to both static and computed properties:"}]},{"syntax":"swift","code":["\/\/ Access through the engine returns proxy objects","let sword = try await engine.item(.magicSword)","let room = try await engine.location(.magicRoom)","let playerProxy = try await engine.player","","\/\/ Proxies provide access to both static and computed properties","let damage = await sword.damage  \/\/ Could be static or computed","let description = await sword.description  \/\/ Dynamic based on current state","let isLit = await room.isLit     \/\/ Automatically computed"],"type":"codeListing"},{"type":"heading","level":2,"text":"Basic Usage with Proxies","anchor":"Basic-Usage-with-Proxies"},{"type":"heading","level":3,"text":"Reading Properties Through Proxies","anchor":"Reading-Properties-Through-Proxies"},{"type":"paragraph","inlineContent":[{"text":"Access properties through proxy objects, which automatically handle both static and computed values:","type":"text"}]},{"syntax":"swift","code":["\/\/ Get proxy objects from the engine","let sword = try await engine.item(.sword)","let door = try await engine.item(.door)","let cave = try await engine.location(.cave)","","\/\/ Access properties through proxies","let description = await sword.description","let isOpen = await door.hasFlag(.isOpen)"],"type":"codeListing"},{"type":"heading","level":3,"text":"Setting Properties (Respecting the Pipeline)","anchor":"Setting-Properties-Respecting-the-Pipeline"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Always use "},{"code":"StateChange","type":"codeVoice"},{"type":"text","text":" builders through proxy objects"}]},{"type":"text","text":" to modify properties:"}]},{"syntax":"swift","code":["\/\/ Create StateChange using proxy builders","let sword = try await engine.item(.sword)","","\/\/ Use proxy methods to create state changes","return ActionResult(","    context.msg.swordSharpened(),","    sword.setProperty(\"sharpness\", to: 8),","    sword.setDescription(\"A gleaming blade\")",")","","\/\/ Flag operations through proxies","let door = try await engine.item(.door)","return ActionResult(","    context.msg.doorOpens(),","    door.setFlag(.isOpen)",")"],"type":"codeListing"},{"type":"heading","level":2,"text":"Validation Through Proxy System","anchor":"Validation-Through-Proxy-System"},{"type":"paragraph","inlineContent":[{"text":"The proxy system includes built-in validation that’s called automatically when ","type":"text"},{"type":"codeVoice","code":"StateChange"},{"text":"s are applied through the action pipeline.","type":"text"}]},{"type":"heading","level":3,"text":"Proxy-Based Validation","anchor":"Proxy-Based-Validation"},{"type":"paragraph","inlineContent":[{"text":"Validation works seamlessly with the proxy system:","type":"text"}]},{"syntax":"swift","code":["\/\/ Validation happens automatically when state changes are applied","let door = try await engine.item(.door)","","\/\/ This will automatically validate through registered handlers","return ActionResult(","    context.msg.doorOpens(),","    door.setFlag(.isOpen)  \/\/ Validation applied here",")"],"type":"codeListing"},{"type":"heading","level":3,"text":"Registering Validation Handlers","anchor":"Registering-Validation-Handlers"},{"type":"paragraph","inlineContent":[{"text":"You can register validation handlers that work with the proxy system:","type":"text"}]},{"syntax":"swift","code":["\/\/ Register through the engine's validation system","await engine.registerItemValidator(itemID: .door, propertyID: .isOpen) { staticItem, newValue, gameState in","    guard case .bool(let isOpening) = newValue else { return false }","","    \/\/ Can only open if not locked","    if isOpening {","        let isLocked = staticItem.properties[.isLocked]?.toBool ?? false","        return !isLocked","    }","    return true","}"],"type":"codeListing"},{"type":"heading","level":3,"text":"Complex State Management with Proxies","anchor":"Complex-State-Management-with-Proxies"},{"type":"paragraph","inlineContent":[{"text":"Inspired by Zork’s troll combat system, using the proxy architecture:","type":"text"}]},{"syntax":"swift","code":["\/\/ Ensure troll state consistency when fighting status changes","await engine.registerItemValidator(itemID: .troll, propertyID: \"fighting\") { staticItem, newValue, gameState in","    guard case .bool(let isFighting) = newValue else { return false }","","    \/\/ If troll stops fighting, it must be unconscious or disarmed","    if !isFighting {","        let hasWeapon = staticItem.properties[\"hasWeapon\"]?.toBool ?? false","        let isUnconscious = staticItem.properties[\"unconscious\"]?.toBool ?? false","        return !hasWeapon || isUnconscious","    }","    return true","}"],"type":"codeListing"},{"type":"heading","level":3,"text":"Validation with Custom Error Messages","anchor":"Validation-with-Custom-Error-Messages"},{"type":"paragraph","inlineContent":[{"text":"Validation handlers can throw specific errors through the messenger system:","type":"text"}]},{"syntax":"swift","code":["await engine.registerItemValidator(itemID: .magicSword, propertyID: \"enchantmentLevel\") { staticItem, newValue, gameState in","    guard case .int(let level) = newValue else {","        throw ActionResponse.feedback(\"Enchantment level must be a number\")","    }","","    if level < 0 || level > 10 {","        throw ActionResponse.feedback(\"Enchantment level must be between 0 and 10\")","    }","","    return true","}"],"type":"codeListing"},{"type":"heading","level":2,"text":"StateChange Builders with Proxies","anchor":"StateChange-Builders-with-Proxies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The proxy system provides convenient builders for creating "},{"type":"codeVoice","code":"StateChange"},{"type":"text","text":" objects that respect the action pipeline:"}]},{"type":"heading","level":3,"text":"Proxy-Based Property Builders","anchor":"Proxy-Based-Property-Builders"},{"syntax":"swift","code":["\/\/ Set properties through proxy objects","let sword = try await engine.item(.sword)","let cave = try await engine.location(.cave)","","\/\/ Proxy methods return StateChange objects","let propertyChange = sword.setProperty(\"customProp\", to: .string(\"value\"))","let temperatureChange = cave.setProperty(\"temperature\", to: .int(72))"],"type":"codeListing"},{"type":"heading","level":3,"text":"Convenience Builders Through Proxies","anchor":"Convenience-Builders-Through-Proxies"},{"syntax":"swift","code":["\/\/ Common patterns have dedicated builders on proxies","let sword = try await engine.item(.sword)","let door = try await engine.item(.door)","let room = try await engine.location(.room)","","let changes = [","    sword.setDescription(\"A new description\"),","    door.setFlag(.isOpen),","    room.clearFlag(.isLit),","    sword.setProperty(\"damage\", to: .int(15)),","    sword.setProperty(\"material\", to: .string(\"steel\"))","]"],"type":"codeListing"},{"type":"heading","level":3,"text":"Using Proxy StateChanges in Action Handlers","anchor":"Using-Proxy-StateChanges-in-Action-Handlers"},{"syntax":"swift","code":["struct OpenActionHandler: ActionHandler {","    func process(context: ActionContext) async throws -> ActionResult {","        guard let targetItemID = context.command.directObjectItemID else {","            throw ActionResponse.feedback(context.msg.doWhat(context.command.verb))","        }","","        let itemProxy = try await context.engine.item(targetItemID)","","        \/\/ Validate the item can be opened","        guard await itemProxy.hasFlag(.isOpenable) else {","            throw ActionResponse.itemNotOpenable(itemProxy)","        }","","        \/\/ Check if already open","        guard !await itemProxy.hasFlag(.isOpen) else {","            throw ActionResponse.itemAlreadyOpen(itemProxy)","        }","","        \/\/ Return result with state change through proxy","        return ActionResult(","            context.msg.openItem(itemProxy.withDefiniteArticle),","            itemProxy.setFlag(.isOpen)","        )","    }","}"],"type":"codeListing"},{"type":"heading","level":2,"text":"ZIL-Inspired Patterns with Proxies","anchor":"ZIL-Inspired-Patterns-with-Proxies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The proxy system enables classic interactive fiction patterns while maintaining concurrency safety:"}]},{"type":"heading","level":3,"text":"Opening and Closing Objects","anchor":"Opening-and-Closing-Objects"},{"syntax":"swift","code":["\/\/ Similar to ZIL's FSET\/FCLEAR for OPENBIT, but through proxies","let chest = try await engine.item(.chest)","return ActionResult(","    context.msg.chestOpens(),","    chest.setFlag(.isOpen)",")"],"type":"codeListing"},{"type":"heading","level":3,"text":"Dynamic Descriptions","anchor":"Dynamic-Descriptions"},{"syntax":"swift","code":["\/\/ Similar to ZIL's PUTP for changing descriptions, with safe proxy access","let troll = try await engine.item(.troll)","","let newDescription = if await troll.isFighting {","    \"A nasty-looking troll, brandishing a bloody axe, blocks all passages.\"","} else {","    \"An unconscious troll is sprawled on the floor.\"","}","","return ActionResult(","    context.msg.trollChangesState(),","    troll.setDescription(newDescription)",")"],"type":"codeListing"},{"type":"heading","level":3,"text":"State Transitions Through Proxies","anchor":"State-Transitions-Through-Proxies"},{"syntax":"swift","code":["\/\/ Complex state changes with validation through the proxy system","let troll = try await engine.item(.troll)","let axe = try await engine.item(.axe)","","return ActionResult(","    context.msg.trollCollapses(),","    troll.setFlag(.unconscious),","    troll.clearFlag(.fighting),","    axe.setFlag(.isVisible),","    axe.setParent(.location(troll.parent))",")"],"type":"codeListing"},{"type":"heading","level":2,"text":"Best Practices with Proxies","anchor":"Best-Practices-with-Proxies"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Always access game objects through proxies"}]},{"text":" instead of direct references","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Use proxy StateChange builders","type":"text"}],"type":"strong"},{"type":"text","text":" instead of direct state mutation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Return proxy StateChanges in ActionResult"}],"type":"strong"},{"text":" to respect the action pipeline","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Use validation handlers","type":"text"}]},{"text":" for complex state dependencies and concurrency safety","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Throw specific errors","type":"text"}]},{"type":"text","text":" to provide clear feedback to players"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Use proxy convenience methods"}],"type":"strong"},{"type":"text","text":" for common patterns like flags and descriptions"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Register validators early","type":"text"}]},{"type":"text","text":" in your game setup, typically in the "},{"type":"codeVoice","code":"GameBlueprint"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Test edge cases"}],"type":"strong"},{"text":" thoroughly, especially concurrent access scenarios","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Leverage computed properties"}]},{"type":"text","text":" through proxies for dynamic content"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Never bypass the proxy system"}]},{"type":"text","text":" for state access or mutations"}]}]}],"type":"orderedList"},{"type":"heading","level":2,"text":"Error Handling with Proxies","anchor":"Error-Handling-with-Proxies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The proxy system throws "},{"type":"codeVoice","code":"ActionResponse"},{"type":"text","text":" errors for various failure conditions:"}]},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"ActionResponse.internalEngineError"},{"type":"text","text":": Item or location doesn’t exist"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"ActionResponse.invalidValue"},{"text":": Validation failed (generic or from validation handlers)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"ActionResponse.concurrencyError","type":"codeVoice"},{"type":"text","text":": Concurrent access violation (rare but possible)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Custom errors: Thrown by validation handlers for specific conditions"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always handle these appropriately in your action handlers:"}]},{"syntax":"swift","code":["do {","    let itemProxy = try await context.engine.item(.someItem)","    let result = ActionResult(","        context.msg.success(),","        itemProxy.setFlag(.processed)","    )","    return result","} catch let response as ActionResponse {","    throw response \/\/ Re-throw ActionResponse for proper error reporting","} catch {","    throw ActionResponse.internalEngineError(\"Unexpected error: \\(error)\")","}"],"type":"codeListing"},{"type":"heading","level":2,"text":"Integration with Action Pipeline and Proxies","anchor":"Integration-with-Action-Pipeline-and-Proxies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The proxy system is fully integrated with the action pipeline:"}]},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Safe Access"}],"type":"strong"},{"text":": Proxies provide thread-safe access to game state with Swift 6 concurrency compliance","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Validation"}],"type":"strong"},{"type":"text","text":": When "},{"code":"StateChange","type":"codeVoice"},{"type":"text","text":"s created by proxies are applied, validation handlers are called automatically"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Event Handlers","type":"text"}]},{"text":": Item and location event handlers can create ","type":"text"},{"code":"StateChange","type":"codeVoice"},{"text":"s through proxies that trigger validation","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Consistency"}]},{"text":": All state mutations flow through the same proxy system validation and application process","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Computed Properties"}]},{"text":": Proxies automatically handle both static and computed properties transparently","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Debugging","type":"text"}]},{"type":"text","text":": All changes are tracked in "},{"type":"codeVoice","code":"gameState.changeHistory"},{"type":"text","text":" with proxy access patterns for debugging"}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This ensures that your game’s state remains consistent, thread-safe, and that all business rules are enforced through the unified proxy system, regardless of how state changes are initiated."}]}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine\/DynamicAttributes"},"schemaVersion":{"patch":0,"major":0,"minor":3},"kind":"article","abstract":[{"type":"text","text":"Learn how to use the proxy system for safe state access and dynamic properties to create sophisticated game mechanics while respecting the action pipeline."}],"references":{"doc://GnustoEngine/documentation/GnustoEngine":{"type":"topic","url":"\/documentation\/gnustoengine","abstract":[],"kind":"symbol","identifier":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine","title":"GnustoEngine","role":"collection"}}}