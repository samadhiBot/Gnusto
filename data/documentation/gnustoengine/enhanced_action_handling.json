{"schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"url":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine\/ENHANCED_ACTION_HANDLING","interfaceLanguage":"swift"},"metadata":{"modules":[{"name":"GnustoEngine"}],"roleHeading":"Article","role":"article","title":"Enhanced Action Handling System Design [DONE]"},"primaryContentSections":[{"content":[{"text":"Overview","anchor":"Overview","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"This document outlines the design for enhancing the existing Gnusto engineâ€™s action handling system. The goal is to build upon the current solid foundation while introducing more powerful capabilities for dynamic content and action handling.","type":"text"}]},{"anchor":"Current-Architecture-Analysis","text":"Current Architecture Analysis","type":"heading","level":2},{"level":3,"text":"Existing Components","anchor":"Existing-Components","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Action Handling","type":"text"}]}]},{"items":[{"content":[{"inlineContent":[{"code":"ActionHandler","type":"codeVoice"},{"text":" protocol with ","type":"text"},{"code":"perform(command:engine:)","type":"codeVoice"},{"type":"text","text":" method"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ItemEventHandler"},{"text":" type for item-specific actions","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Well-organized action handlers for common verbs"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"State Management"}],"type":"strong"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"GameState","type":"codeVoice"},{"type":"text","text":" class for overall game state"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"Item"},{"text":" and ","type":"text"},{"code":"Location","type":"codeVoice"},{"type":"text","text":" types with properties"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"AnyCodable","type":"codeVoice"},{"type":"text","text":" for flexible property values"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Command Processing"}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"Command","type":"codeVoice"},{"type":"text","text":" type for representing player actions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ScopeResolver"},{"type":"text","text":" for object resolution"}]}]}]}]}],"type":"orderedList"},{"type":"heading","anchor":"Enhancement-Strategy","text":"Enhancement Strategy","level":2},{"anchor":"1-Action-Pipeline-Enhancement","level":3,"text":"1. Action Pipeline Enhancement","type":"heading"},{"code":["\/\/\/ Enhanced ActionHandler protocol with pipeline support","public protocol ActionHandler: ActionHandler {","    \/\/\/ Validate if the action can be performed","    func validate(command: Command, engine: GameEngine) async throws","","    \/\/\/ Process the action and return detailed results","    func process(command: Command, engine: GameEngine) async throws -> ActionResult","","    \/\/\/ Handle any post-action effects","    func postProcess(command: Command, engine: GameEngine, result: ActionResult) async throws","}","","\/\/\/ Result of an action execution with enhanced information","public struct ActionResult {","    \/\/\/ Whether the action was successful","    public let success: Bool","","    \/\/\/ Message to display to the player","    public let message: String","","    \/\/\/ Any state changes that occurred","    public let stateChanges: [StateChange]","","    \/\/\/ Any side effects that need to be processed","    public let sideEffects: [SideEffect]","}","","\/\/\/ Represents a change in game state","public struct StateChange {","    \/\/\/ The object being changed","    public let objectId: ItemID","","    \/\/\/ The property being modified","    public let property: String","","    \/\/\/ The new value","    public let value: AnyCodable","}","","\/\/\/ Represents a side effect of an action","public struct SideEffect {","    \/\/\/ The type of side effect","    public let type: SideEffectType","","    \/\/\/ The target of the effect","    public let target: ItemID","","    \/\/\/ Any additional parameters","    public let parameters: [String: AnyCodable]","}"],"syntax":"swift","type":"codeListing"},{"type":"heading","anchor":"2-Dynamic-Logic--State-System","level":3,"text":"2. Dynamic Logic & State System"},{"inlineContent":[{"text":"This system allows associating dynamic computation and validation logic with specific properties of Items or Locations, while storing the actual state values separately.","type":"text"}],"type":"paragraph"},{"code":["\/\/\/ A strongly-typed identifier for game properties.","public struct AttributeID: Hashable, Codable, Sendable { \/* ... *\/ }","","\/\/\/ The standard type for storing potentially dynamic state values.","public enum StateValue: Codable, Sendable { \/* ... *\/ }","","\/\/ --- Game Developer Interaction Points ---","","\/\/\/ Items store their specific state values using AttributeID keys.","\/\/\/ (Example structure - actual might differ slightly)","public struct Item: Sendable, Codable {","    \/\/ ... other properties ...","    public var attributes: [AttributeID: StateValue]","}","","\/\/\/ Locations also store their state values.","public struct Location: Sendable, Codable {","    \/\/ ... other properties ...","    public var attributes: [AttributeID: StateValue]","}","","\/\/\/ Registry for dynamic behavior (part of GameBlueprint or DefinitionRegistry).","public struct DynamicAttributeRegistry: Sendable {","    \/\/\/ Closure type for computing an item property's value.","    public typealias ItemComputeHandler =","        (@Sendable (Item, GameState) -> StateValue)","    \/\/\/ Closure type for validating a new value for an item property.","    public typealias ItemValidateHandler =","        (@Sendable (Item, StateValue) -> Bool)","","    \/\/ ... Similar types for Location handlers ...","","    \/\/\/ Registers a compute handler for a specific item property.","    public func registerItemCompute(","        key: AttributeID,","        handler: @escaping ItemComputeHandler","    ) { \/* ... *\/ }","","    \/\/\/ Registers a validation handler for a specific item property.","    public func registerItemValidate(","        key: AttributeID,","        handler: @escaping ItemValidateHandler","    ) { \/* ... *\/ }","","    \/\/ ... Methods to retrieve handlers ...","}","","\/\/\/ Engine provides helpers to access values (handles registry lookup + state access).","public class GameEngine: Sendable {","    \/\/\/ Gets the current value, checking compute handlers first.","    public func getDynamicItemValue(","        itemID: ItemID,","        key: AttributeID","    ) async -> StateValue? { \/* ... *\/ }","","    \/\/\/ Sets a value after checking validate handlers and applying a StateChange.","    public func setDynamicItemValue(","        itemID: ItemID,","        key: AttributeID,","        newValue: StateValue","    ) async throws { \/* ... *\/ }","","    \/\/ ... Similar helpers for Locations ...","}"],"type":"codeListing","syntax":"swift"},{"text":"3. Action Context System","level":3,"anchor":"3-Action-Context-System","type":"heading"},{"syntax":"swift","type":"codeListing","code":["\/\/\/ Context for action execution","public struct ActionContext {","    \/\/\/ The command being executed","    public let command: Command","","    \/\/\/ The game engine instance","    public let engine: GameEngine","","    \/\/\/ The current game state","    public let state: GameState","","    \/\/\/ Any additional context data","    public let contextData: [String: AnyCodable]","}","","\/\/\/ Protocol for objects that can provide action context","public protocol ActionContextProvider {","    \/\/\/ Get context for an action","    func getContext(for command: Command) async throws -> ActionContext","}"]},{"type":"heading","text":"Implementation Phases","level":2,"anchor":"Implementation-Phases"},{"anchor":"Phase-1-Core-Enhancements","type":"heading","level":3,"text":"Phase 1: Core Enhancements"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extend "},{"type":"codeVoice","code":"ActionHandler"},{"type":"text","text":" protocol with pipeline support"}]}],"checked":true},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement "},{"type":"codeVoice","code":"ActionResult"},{"text":" and related types","type":"text"}]}],"checked":true},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add state change tracking to "},{"type":"codeVoice","code":"GameState"}]}],"checked":true}],"type":"unorderedList"},{"anchor":"Phase-2-Dynamic-Logic--State-System","level":3,"type":"heading","text":"Phase 2: Dynamic Logic & State System"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Define ","type":"text"},{"type":"codeVoice","code":"AttributeID"},{"text":" type.","type":"text"}]}],"checked":true},{"checked":true,"content":[{"type":"paragraph","inlineContent":[{"text":"Create ","type":"text"},{"type":"codeVoice","code":"DynamicAttributeRegistry"},{"text":" for compute\/validate handlers.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Add "},{"code":"attributes: [AttributeID: StateValue]","type":"codeVoice"},{"type":"text","text":" to "},{"type":"codeVoice","code":"Item"},{"text":" and ","type":"text"},{"code":"Location","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"checked":true},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Update "},{"type":"codeVoice","code":"StatePropertyKey"},{"type":"text","text":" and "},{"code":"GameState.apply","type":"codeVoice"},{"type":"text","text":" to handle changes to "},{"type":"codeVoice","code":"attributes"},{"text":".","type":"text"}]}],"checked":true},{"checked":true,"content":[{"inlineContent":[{"text":"Implement ","type":"text"},{"type":"codeVoice","code":"GameEngine"},{"type":"text","text":" helpers ("},{"type":"codeVoice","code":"get\/setDynamic...Value"},{"text":") to orchestrate registry\/state access.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Phase 3: Context System","level":3,"anchor":"Phase-3-Context-System","type":"heading"},{"type":"unorderedList","items":[{"checked":true,"content":[{"inlineContent":[{"type":"text","text":"Implement "},{"type":"codeVoice","code":"ActionContext"},{"text":" system","type":"text"}],"type":"paragraph"}]},{"checked":true,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add context providers for common scenarios"}]}]},{"checked":true,"content":[{"type":"paragraph","inlineContent":[{"text":"Integrate with existing action handlers","type":"text"}]}]}]},{"anchor":"Phase-4-Migration","level":3,"type":"heading","text":"Phase 4: Migration"},{"items":[{"content":[{"inlineContent":[{"text":"Update existing action handlers to use new system","type":"text"}],"type":"paragraph"}],"checked":true},{"checked":true,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add support for dynamic descriptions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Implement state-dependent behavior","type":"text"}]}],"checked":true}],"type":"unorderedList"},{"text":"Testing Strategy","level":2,"anchor":"Testing-Strategy","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Unit Tests","type":"text"}]}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Test enhanced action handlers","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Verify dynamic properties"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Check context system","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Integration Tests","type":"text"}]}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Test action pipeline","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Verify state changes","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Check side effects","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Migration Tests"}]}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Verify existing functionality","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Test new features"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Check performance impact","type":"text"}]}]}],"type":"unorderedList"}]}],"type":"orderedList"},{"type":"heading","level":2,"anchor":"Migration-Guide","text":"Migration Guide"},{"level":3,"text":"For Action Handlers","type":"heading","anchor":"For-Action-Handlers"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Simple Migration"}]}]}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Before","public struct SimpleActionHandler: ActionHandler {","    func perform(command: Command, engine: GameEngine) async throws {","        \/\/ Implementation","    }","}","","\/\/ After","public struct ActionHandler: ActionHandler {","    func perform(command: Command, engine: GameEngine) async throws {","        try await validate(command: command, engine: engine)","        let result = try await process(command: command, engine: engine)","        try await postProcess(command: command, engine: engine, result: result)","    }","","    \/\/ New methods","    func validate(command: Command, engine: GameEngine) async throws {","        \/\/ Validation logic","    }","","    func process(command: Command, engine: GameEngine) async throws -> ActionResult {","        \/\/ Processing logic","    }","","    func postProcess(command: Command, engine: GameEngine, result: ActionResult) async throws {","        \/\/ Post-processing logic","    }","}"]},{"type":"orderedList","start":2,"items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Dynamic Properties","type":"text"}],"type":"strong"}],"type":"paragraph"}]}]},{"syntax":"swift","code":["\/\/ Before","item.attributes[\"isOpen\"] = true","","\/\/ After (Conceptual Example)","\/\/ 1. Define AttributeID","\/\/ extension AttributeID { static let isOpen = AttributeID(\"isOpen\") }","\/\/ 2. Register validation handler (optional, during setup)","\/\/ registry.registerItemValidate(key: .isOpen) { item, newValue in ... }","\/\/ 3. Set value using engine helper (triggers validation & StateChange)","\/\/ try await engine.setDynamicItemValue(itemID: item.id, key: .isOpen, newValue: true,)","\/\/ 4. Get value using engine helper (checks compute handlers)","\/\/ let isOpen = await engine.getDynamicItemValue(itemID: item.id, key: .isOpen)?.toBool ?? false"],"type":"codeListing"},{"type":"heading","level":2,"anchor":"Conclusion","text":"Conclusion"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This enhanced design builds upon the existing Gnusto engine architecture while introducing more powerful capabilities for dynamic content and action handling. The design maintains backward compatibility while providing a path forward for more sophisticated game mechanics."}]}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/gnustoengine\/enhanced_action_handling"]}],"kind":"article","sections":[],"hierarchy":{"paths":[["doc:\/\/GnustoEngine\/documentation\/GnustoEngine"]]},"references":{"doc://GnustoEngine/documentation/GnustoEngine":{"url":"\/documentation\/gnustoengine","abstract":[],"identifier":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine","role":"collection","type":"topic","title":"GnustoEngine","kind":"symbol"}}}