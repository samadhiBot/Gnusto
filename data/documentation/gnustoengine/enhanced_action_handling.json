{"hierarchy":{"paths":[["doc:\/\/GnustoEngine\/documentation\/GnustoEngine"]]},"sections":[],"identifier":{"url":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine\/ENHANCED_ACTION_HANDLING","interfaceLanguage":"swift"},"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/gnustoengine\/enhanced_action_handling"]}],"metadata":{"role":"article","title":"Enhanced Action Handling System Design [DONE]","modules":[{"name":"GnustoEngine"}],"roleHeading":"Article"},"primaryContentSections":[{"content":[{"anchor":"Overview","text":"Overview","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"This document outlines the design for enhancing the existing Gnusto engineâ€™s action handling system. The goal is to build upon the current solid foundation while introducing more powerful capabilities for dynamic content and action handling."}]},{"level":2,"text":"Current Architecture Analysis","type":"heading","anchor":"Current-Architecture-Analysis"},{"text":"Existing Components","type":"heading","level":3,"anchor":"Existing-Components"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Action Handling","type":"text"}],"type":"strong"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"ActionHandler","type":"codeVoice"},{"type":"text","text":" protocol with "},{"type":"codeVoice","code":"perform(command:engine:)"},{"type":"text","text":" method"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"ItemEventHandler","type":"codeVoice"},{"text":" type for item-specific actions","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Well-organized action handlers for common verbs"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"State Management"}]}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"code":"GameState","type":"codeVoice"},{"type":"text","text":" class for overall game state"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"Item","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Location"},{"type":"text","text":" types with properties"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"AnyCodable"},{"type":"text","text":" for flexible property values"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Command Processing"}],"type":"strong"}]},{"items":[{"content":[{"inlineContent":[{"code":"Command","type":"codeVoice"},{"text":" type for representing player actions","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ScopeResolver"},{"type":"text","text":" for object resolution"}]}]}],"type":"unorderedList"}]}]},{"type":"heading","text":"Enhancement Strategy","anchor":"Enhancement-Strategy","level":2},{"text":"1. Action Pipeline Enhancement","anchor":"1-Action-Pipeline-Enhancement","level":3,"type":"heading"},{"syntax":"swift","type":"codeListing","code":["\/\/\/ Enhanced ActionHandler protocol with pipeline support","public protocol ActionHandler: ActionHandler {","    \/\/\/ Validate if the action can be performed","    func validate(command: Command, engine: GameEngine) async throws","","    \/\/\/ Process the action and return detailed results","    func process(command: Command, engine: GameEngine) async throws -> ActionResult","","    \/\/\/ Handle any post-action effects","    func postProcess(command: Command, engine: GameEngine, result: ActionResult) async throws","}","","\/\/\/ Result of an action execution with enhanced information","public struct ActionResult {","    \/\/\/ Whether the action was successful","    public let success: Bool","","    \/\/\/ Message to display to the player","    public let message: String","","    \/\/\/ Any state changes that occurred","    public let stateChanges: [StateChange]","","    \/\/\/ Any side effects that need to be processed","    public let sideEffects: [SideEffect]","}","","\/\/\/ Represents a change in game state","public struct StateChange {","    \/\/\/ The object being changed","    public let objectId: ItemID","","    \/\/\/ The property being modified","    public let property: String","","    \/\/\/ The new value","    public let value: AnyCodable","}","","\/\/\/ Represents a side effect of an action","public struct SideEffect {","    \/\/\/ The type of side effect","    public let type: SideEffectType","","    \/\/\/ The target of the effect","    public let target: ItemID","","    \/\/\/ Any additional parameters","    public let parameters: [String: AnyCodable]","}"]},{"anchor":"2-Dynamic-Logic--State-System","text":"2. Dynamic Logic & State System","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This system allows associating dynamic computation and validation logic with specific properties of Items or Locations, while storing the actual state values separately."}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A strongly-typed identifier for game properties.","public struct AttributeID: Hashable, Codable, Sendable { \/* ... *\/ }","","\/\/\/ The standard type for storing potentially dynamic state values.","public enum StateValue: Codable, Sendable { \/* ... *\/ }","","\/\/ --- Game Developer Interaction Points ---","","\/\/\/ Items store their specific state values using AttributeID keys.","\/\/\/ (Example structure - actual might differ slightly)","public struct Item: Sendable, Codable {","    \/\/ ... other properties ...","    public var attributes: [AttributeID: StateValue]","}","","\/\/\/ Locations also store their state values.","public struct Location: Sendable, Codable {","    \/\/ ... other properties ...","    public var attributes: [AttributeID: StateValue]","}","","\/\/\/ Registry for dynamic behavior (part of GameBlueprint or DefinitionRegistry).","public struct DynamicAttributeRegistry: Sendable {","    \/\/\/ Closure type for computing an item property's value.","    public typealias ItemComputeHandler =","        (@Sendable (Item, GameState) -> StateValue)","    \/\/\/ Closure type for validating a new value for an item property.","    public typealias ItemValidateHandler =","        (@Sendable (Item, StateValue) -> Bool)","","    \/\/ ... Similar types for Location handlers ...","","    \/\/\/ Registers a compute handler for a specific item property.","    public func registerItemCompute(","        key: AttributeID,","        handler: @escaping ItemComputeHandler","    ) { \/* ... *\/ }","","    \/\/\/ Registers a validation handler for a specific item property.","    public func registerItemValidate(","        key: AttributeID,","        handler: @escaping ItemValidateHandler","    ) { \/* ... *\/ }","","    \/\/ ... Methods to retrieve handlers ...","}","","\/\/\/ Engine provides helpers to access values (handles registry lookup + state access).","public class GameEngine: Sendable {","    \/\/\/ Gets the current value, checking compute handlers first.","    public func getDynamicItemValue(","        itemID: ItemID,","        key: AttributeID","    ) async -> StateValue? { \/* ... *\/ }","","    \/\/\/ Sets a value after checking validate handlers and applying a StateChange.","    public func setDynamicItemValue(","        itemID: ItemID,","        key: AttributeID,","        newValue: StateValue","    ) async throws { \/* ... *\/ }","","    \/\/ ... Similar helpers for Locations ...","}"]},{"type":"heading","level":3,"text":"3. Action Context System","anchor":"3-Action-Context-System"},{"code":["\/\/\/ Context for action execution","public struct ActionContext {","    \/\/\/ The command being executed","    public let command: Command","","    \/\/\/ The game engine instance","    public let engine: GameEngine","","    \/\/\/ The current game state","    public let state: GameState","","    \/\/\/ Any additional context data","    public let contextData: [String: AnyCodable]","}","","\/\/\/ Protocol for objects that can provide action context","public protocol ActionContextProvider {","    \/\/\/ Get context for an action","    func getContext(for command: Command) async throws -> ActionContext","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Implementation Phases","anchor":"Implementation-Phases","level":2},{"anchor":"Phase-1-Core-Enhancements","level":3,"type":"heading","text":"Phase 1: Core Enhancements"},{"type":"unorderedList","items":[{"checked":true,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extend "},{"type":"codeVoice","code":"ActionHandler"},{"type":"text","text":" protocol with pipeline support"}]}]},{"checked":true,"content":[{"inlineContent":[{"text":"Implement ","type":"text"},{"code":"ActionResult","type":"codeVoice"},{"text":" and related types","type":"text"}],"type":"paragraph"}]},{"checked":true,"content":[{"inlineContent":[{"text":"Add state change tracking to ","type":"text"},{"code":"GameState","type":"codeVoice"}],"type":"paragraph"}]}]},{"anchor":"Phase-2-Dynamic-Logic--State-System","text":"Phase 2: Dynamic Logic & State System","type":"heading","level":3},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Define ","type":"text"},{"code":"AttributeID","type":"codeVoice"},{"text":" type.","type":"text"}],"type":"paragraph"}],"checked":true},{"content":[{"inlineContent":[{"text":"Create ","type":"text"},{"type":"codeVoice","code":"DynamicAttributeRegistry"},{"type":"text","text":" for compute\/validate handlers."}],"type":"paragraph"}],"checked":true},{"checked":true,"content":[{"type":"paragraph","inlineContent":[{"text":"Add ","type":"text"},{"type":"codeVoice","code":"attributes: [AttributeID: StateValue]"},{"text":" to ","type":"text"},{"type":"codeVoice","code":"Item"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Location"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Update "},{"code":"StatePropertyKey","type":"codeVoice"},{"type":"text","text":" and "},{"code":"GameState.apply","type":"codeVoice"},{"type":"text","text":" to handle changes to "},{"type":"codeVoice","code":"attributes"},{"type":"text","text":"."}]}],"checked":true},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement "},{"code":"GameEngine","type":"codeVoice"},{"text":" helpers (","type":"text"},{"type":"codeVoice","code":"get\/setDynamic...Value"},{"type":"text","text":") to orchestrate registry\/state access."}]}],"checked":true}]},{"anchor":"Phase-3-Context-System","type":"heading","text":"Phase 3: Context System","level":3},{"items":[{"checked":true,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement "},{"type":"codeVoice","code":"ActionContext"},{"type":"text","text":" system"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add context providers for common scenarios"}]}],"checked":true},{"checked":true,"content":[{"type":"paragraph","inlineContent":[{"text":"Integrate with existing action handlers","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"text":"Phase 4: Migration","anchor":"Phase-4-Migration","type":"heading"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Update existing action handlers to use new system"}]}],"checked":true},{"content":[{"type":"paragraph","inlineContent":[{"text":"Add support for dynamic descriptions","type":"text"}]}],"checked":true},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement state-dependent behavior"}]}],"checked":true}]},{"text":"Testing Strategy","anchor":"Testing-Strategy","type":"heading","level":2},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Unit Tests"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Test enhanced action handlers","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Verify dynamic properties","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Check context system","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Integration Tests","type":"text"}]}]},{"items":[{"content":[{"inlineContent":[{"text":"Test action pipeline","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Verify state changes","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Check side effects"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Migration Tests","type":"text"}],"type":"strong"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Verify existing functionality"}]}]},{"content":[{"inlineContent":[{"text":"Test new features","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Check performance impact"}],"type":"paragraph"}]}]}]}]},{"text":"Migration Guide","type":"heading","anchor":"Migration-Guide","level":2},{"text":"For Action Handlers","type":"heading","level":3,"anchor":"For-Action-Handlers"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Simple Migration"}],"type":"strong"}]}]}]},{"syntax":"swift","code":["\/\/ Before","public struct SimpleActionHandler: ActionHandler {","    func perform(command: Command, engine: GameEngine) async throws {","        \/\/ Implementation","    }","}","","\/\/ After","public struct ActionHandler: ActionHandler {","    func perform(command: Command, engine: GameEngine) async throws {","        try await validate(command: command, engine: engine)","        let result = try await process(command: command, engine: engine)","        try await postProcess(command: command, engine: engine, result: result)","    }","","    \/\/ New methods","    func validate(command: Command, engine: GameEngine) async throws {","        \/\/ Validation logic","    }","","    func process(command: Command, engine: GameEngine) async throws -> ActionResult {","        \/\/ Processing logic","    }","","    func postProcess(command: Command, engine: GameEngine, result: ActionResult) async throws {","        \/\/ Post-processing logic","    }","}"],"type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Dynamic Properties","type":"text"}]}],"type":"paragraph"}]}],"start":2,"type":"orderedList"},{"syntax":"swift","code":["\/\/ Before","item.attributes[\"isOpen\"] = true","","\/\/ After (Conceptual Example)","\/\/ 1. Define AttributeID","\/\/ extension AttributeID { static let isOpen = AttributeID(\"isOpen\") }","\/\/ 2. Register validation handler (optional, during setup)","\/\/ registry.registerItemValidate(key: .isOpen) { item, newValue in ... }","\/\/ 3. Set value using engine helper (triggers validation & StateChange)","\/\/ try await engine.setDynamicItemValue(itemID: item.id, key: .isOpen, newValue: true,)","\/\/ 4. Get value using engine helper (checks compute handlers)","\/\/ let isOpen = await engine.getDynamicItemValue(itemID: item.id, key: .isOpen)?.toBool ?? false"],"type":"codeListing"},{"anchor":"Conclusion","type":"heading","text":"Conclusion","level":2},{"inlineContent":[{"text":"This enhanced design builds upon the existing Gnusto engine architecture while introducing more powerful capabilities for dynamic content and action handling. The design maintains backward compatibility while providing a path forward for more sophisticated game mechanics.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"references":{"doc://GnustoEngine/documentation/GnustoEngine":{"title":"GnustoEngine","identifier":"doc:\/\/GnustoEngine\/documentation\/GnustoEngine","role":"collection","kind":"symbol","type":"topic","url":"\/documentation\/gnustoengine","abstract":[]}}}