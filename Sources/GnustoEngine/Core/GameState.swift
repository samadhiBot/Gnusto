import Foundation

/// Represents the complete, mutable state of the game world at a given point in time.
///
/// `GameState` is the single source of truth for all dynamic data in your game, including
/// item states and locations, player status, active timed events, and global flags.
/// You will primarily interact with a snapshot of `GameState` provided in `ActionContext`
/// when writing game logic like `ActionHandler`s.
///
/// While you can read all properties of a `GameState` snapshot, all modifications to the
/// actual game state are managed by the `GameEngine`. These modifications are performed by
/// applying `StateChange` objects (often generated by your action handlers) via the
/// `apply(_:)` method. This ensures that all changes are centralized, validated, and tracked.
public struct GameState: Codable, Equatable, Sendable {
    /// A dictionary of all items currently existing in the game world, indexed by their unique `ItemID`.
    /// You can inspect this to find any item's current properties and status.
    public private(set) var items: [ItemID: Item]

    /// A dictionary of all locations defined in the game, indexed by their unique `LocationID`.
    /// Use this to access information about any location.
    public private(set) var locations: [LocationID: Location]

    /// An object representing the player character, containing their current status, inventory,
    /// score, location, etc.
    public private(set) var player: Player

    /// A dictionary of active "fuses" (timed events), mapping each `FuseID` to its runtime state.
    /// The state includes both the number of turns remaining and any custom data associated with
    /// the fuse instance. Fuses are timed events that can optionally store contextual information.
    public private(set) var activeFuses: [FuseID: FuseState]

    /// A dictionary of active daemon states, keyed by `DaemonID`.
    /// Each daemon maintains its own state that persists between executions.
    public private(set) var activeDaemons: [DaemonID: DaemonState]

    /// A pronoun (e.g., "it", "them", "her") that refers to one or more `EntityReference`s.
    ///
    /// This is managed by the game engine to resolve pronoun usage in player commands.
    public private(set) var pronoun: Pronoun?

    /// A dictionary for storing arbitrary game-specific data using `GlobalID` keys and
    /// `StateValue`s. This is useful for tracking custom global flags, counters, or other
    /// state that doesn't fit into the predefined properties.
    public private(set) var globalState: [GlobalID: StateValue]

    /// An array history of all `StateChange` objects that have been successfully applied to
    /// this `GameState` instance since its creation or last load. Useful for debugging or replay.
    public private(set) var changeHistory: [StateChange]

    /// Initializes a `GameState` with explicitly provided collections of locations, items,
    /// player data, and other core state components.
    ///
    /// This initializer is useful for:
    /// - Programmatically constructing a game world from scratch.
    /// - Deserializing a game state from a saved file.
    /// - Setting up specific scenarios for testing.
    ///

    /// - Parameters:
    ///   - locations: An array of all `Location` objects for the game.
    ///   - items: An array of all `Item` objects for the game.
    ///   - player: The `Player` object representing the player's initial state.

    ///   - pronoun: Optional. Initial pronoun reference.
    ///   - activeFuses: Optional. Initially active fuses and their states.
    ///   - activeDaemons: Optional. Initially active daemons and their states.
    ///   - globalState: Optional. Initial game-specific global key-value data.
    ///   - changeHistory: Optional. An initial history of changes, typically empty for a new game.
    public init(
        locations: [Location],
        items: [Item],
        player: Player,
        pronoun: Pronoun? = nil,
        activeFuses: [FuseID: FuseState] = [:],
        activeDaemons: [DaemonID: DaemonState] = [:],
        globalState: [GlobalID: StateValue] = [:],
        changeHistory: [StateChange] = []
    ) {
        self.items = Dictionary(uniqueKeysWithValues: items.map { ($0.id, $0) })
        self.locations = Dictionary(uniqueKeysWithValues: locations.map { ($0.id, $0) })
        self.player = player
        self.pronoun = pronoun
        self.activeFuses = activeFuses
        self.activeDaemons = activeDaemons
        self.globalState = globalState
        self.changeHistory = changeHistory
    }
}

// MARK: - State Mutation

extension GameState {
    /// Applies one or more `StateChange` objects to the game state.
    ///
    /// This is the sole, centralized method for mutating the `GameState`. It is typically
    /// called by the `GameEngine` after an `ActionHandler` (or other game logic) determines
    /// that the state needs to change.
    ///
    /// The method processes each `StateChange`, validates it, applies the modification to the
    /// relevant property (e.g., an item's parent, player's score, a global flag), and records
    /// the change in `changeHistory`.
    ///
    /// If a `StateChange` is `nil` (due to being an optional parameter), it is ignored.
    ///
    /// - Parameter changes: A variadic list of optional `StateChange` objects to apply.
    /// - Throws: `ActionResponse.internalEngineError` if any cannot be applied.
    mutating func apply(_ changes: StateChange?...) throws {
        for stateChange in changes {
            if let stateChange {
                try apply(change: stateChange)
            }
        }
    }

    /// Applies a `StateChange` to the game state, modifying the relevant property and recording the change.
    private mutating func apply(change: StateChange) throws {
        switch change {

        // MARK: - GameEngine State Changes

        case .requestGameQuit:
            break

        case .requestGameRestart:
            break

        // MARK: - Item State Changes

        case .moveItem(let itemID, let newParent):
            guard items[itemID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Item \(itemID.rawValue) not found for move operation"
                )
            }
            items[itemID]?.properties[.parentEntity] = .parentEntity(newParent)

        case .setItemProperty(let itemID, let propertyID, let value):
            guard items[itemID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Item \(itemID.rawValue) not found for property change"
                )
            }
            items[itemID]?.properties[propertyID] = value

        case .setItemName(let itemID, let name):
            guard items[itemID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Item \(itemID.rawValue) not found for name change"
                )
            }
            items[itemID]?.properties[.name] = .string(name)

        case .setItemAdjectives(let itemID, let adjectives):
            guard items[itemID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Item \(itemID.rawValue) not found for adjectives change"
                )
            }
            items[itemID]?.properties[.adjectives] = .stringSet(Set(adjectives))

        case .setItemCapacity(let itemID, let capacity):
            guard items[itemID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Item \(itemID.rawValue) not found for capacity change"
                )
            }
            items[itemID]?.properties[.capacity] = .int(capacity)

        case .setItemSize(let itemID, let size):
            guard items[itemID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Item \(itemID.rawValue) not found for size change"
                )
            }
            items[itemID]?.properties[.size] = .int(size)

        case .setItemSynonyms(let itemID, let synonyms):
            guard items[itemID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Item \(itemID.rawValue) not found for synonyms change"
                )
            }
            items[itemID]?.properties[.synonyms] = .stringSet(Set(synonyms))

        case .setItemValue(let itemID, let value):
            guard items[itemID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Item \(itemID.rawValue) not found for value change"
                )
            }
            items[itemID]?.properties[.value] = .int(value)

        // MARK: - Location State Changes

        case .setLocationProperty(let locationID, let propertyID, let value):
            guard locations[locationID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Location \(locationID.rawValue) not found for property change"
                )
            }
            locations[locationID]?.properties[propertyID] = value

        case .setLocationDescription(let locationID, let description):
            guard locations[locationID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Location \(locationID.rawValue) not found for description change"
                )
            }
            locations[locationID]?.properties[.description] = .string(description)

        case .setLocationName(let locationID, let name):
            guard locations[locationID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Location \(locationID.rawValue) not found for name change"
                )
            }
            locations[locationID]?.properties[.name] = .string(name)

        case .setLocationExits(let locationID, let exits):
            guard locations[locationID] != nil else {
                throw ActionResponse.internalEngineError(
                    "Location \(locationID.rawValue) not found for exits change"
                )
            }
            locations[locationID]?.properties[.exits] = .exits(exits)

        // MARK: - Player State Changes

        case .movePlayer(let locationID):
            player.currentLocationID = locationID

        case .movePlayerTo(let parent):
            switch parent {
            case .location(let locationID):
                player.currentLocationID = locationID
            default:
                throw ActionResponse.internalEngineError(
                    "Player can only be moved to locations, not \(parent)"
                )
            }

        case .setPlayerScore(let score):
            player.score = score

        case .setPlayerAttributes(let attributes):
            player.characterSheet = attributes

        case .incrementPlayerMoves:
            player.moves += 1

        // MARK: - Global State Changes

        case .setFlag(let globalID):
            globalState[globalID] = .bool(true)

        case .clearFlag(let globalID):
            globalState[globalID] = .bool(false)

        case .setGlobalBool(let globalID, let value):
            globalState[globalID] = .bool(value)

        case .setGlobalCodable(let globalID, let value):
            globalState[globalID] = .codable(value)

        case .setGlobalInt(let globalID, let value):
            globalState[globalID] = .int(value)

        case .setGlobalString(let globalID, let value):
            globalState[globalID] = .string(value)

        case .setGlobalItemID(let globalID, let value):
            globalState[globalID] = .itemID(value)

        case .setGlobalLocationID(let globalID, let value):
            globalState[globalID] = .locationID(value)

        case .setGlobalState(let globalID, let value):
            globalState[globalID] = value

        case .clearGlobalState(let globalID):
            globalState.removeValue(forKey: globalID)

        case .setCombatState(let combatState):
            if let combatState {
                globalState[.combatState] = .combatState(combatState)
            } else {
                globalState.removeValue(forKey: .combatState)
            }

        // MARK: - Timed Events (Fuses & Daemons)

        case .addActiveDaemon(let daemonID, let daemonState):
            activeDaemons[daemonID] = daemonState

        case .removeActiveDaemon(let daemonID):
            activeDaemons.removeValue(forKey: daemonID)

        case .updateDaemonState(let daemonID, let daemonState):
            activeDaemons[daemonID] = daemonState

        case .addActiveFuse(let fuseID, let fuseState):
            activeFuses[fuseID] = fuseState

        case .removeActiveFuse(let fuseID):
            activeFuses.removeValue(forKey: fuseID)

        case .updateFuseTurns(let fuseID, let turns):
            guard var fuseState = activeFuses[fuseID] else {
                throw ActionResponse.internalEngineError(
                    "Fuse \(fuseID.rawValue) not found for turns update"
                )
            }
            fuseState.turns = turns
            activeFuses[fuseID] = fuseState
        }

        changeHistory.append(change)
    }

    mutating func updatePronoun(to pronoun: Pronoun?) {
        self.pronoun = pronoun
    }
}

// MARK: - GameStateError

enum GameStateError: Error {
    case globalTypeMismatch(GlobalID, actual: StateValue)
    case itemPropertyTypeMismatch(ItemID, ItemPropertyID, actual: StateValue)
    case itemNotFound(ItemID)
    case locationPropertyTypeMismatch(LocationID, LocationPropertyID, actual: StateValue)
    case locationNotFound(LocationID)
}
