import Foundation

/// Handles the "EXAMINE" command and its synonyms (e.g., "LOOK AT", "DESCRIBE"), providing
/// a detailed description of a specified item or the player.
public struct ExamineActionHandler: ActionHandler {
    /// Validates the "EXAMINE" command.
    ///
    /// This method ensures that:
    /// 1. A direct object is specified (the player must indicate *what* to examine).
    /// 2. If the direct object is an item, it must exist and be reachable by the player.
    /// 3. Examining the player ("EXAMINE SELF") is also permitted.
    ///
    /// - Parameter context: The `ActionContext` for the current action.
    /// - Throws: `ActionResponse.custom` if no direct object is provided,
    ///           `ActionResponse.unknownEntity` if an item direct object does not exist,
    ///           `ActionResponse.itemNotAccessible` if an item cannot be reached, or
    ///           `ActionResponse.prerequisiteNotMet` if trying to examine something other
    ///           than an item or the player.
    public func validate(context: ActionContext) async throws {
        // For ALL commands, allow empty directObjects (handled in process method)
        if context.command.isAllCommand {
            return
        }
        
        // 1. Ensure we have at least one direct object for non-ALL commands
        guard !context.command.directObjects.isEmpty else {
            throw ActionResponse.custom("Examine what?")
        }
        
        // For single object commands, validate the single object
        guard let directObjectRef = context.command.directObject else {
            throw ActionResponse.custom("Examine what?")
        }
        
        switch directObjectRef {
        case .item(let targetItemID):
            // 2. Check if item exists
            guard (try? await context.engine.item(targetItemID)) != nil else {
                throw ActionResponse.unknownEntity(directObjectRef)
            }
            // 3. Check reachability
            guard await context.engine.playerCanReach(targetItemID) else {
                throw ActionResponse.itemNotAccessible(targetItemID)
            }
        case .player:
            // Allow examining self
            return
        default:
            throw ActionResponse.prerequisiteNotMet("You can only examine items.")
        }
    }

    /// Processes the "EXAMINE" command.
    ///
    /// - If the direct object is the player ("EXAMINE SELF"), a standard message is returned.
    /// - If the direct object is an item (validation ensures it exists and is reachable):
    ///   1. The item is marked with the `.isTouched` flag (unless it's the "self" item).
    ///   2. Pronouns are updated to refer to this item (unless it's the "self" item).
    ///   3. A description is generated with the following priority:
    ///      a. If the item `.isReadable` and has non-empty `.readText`, that text is shown.
    ///      b. If the item `.isContainer` or `.isDoor`, a description including its contents
    ///         (if open/transparent) or closed state is generated by `describeContainerOrDoor()`.
    ///      c. If the item `.isSurface`, a description including items on it is generated by
    ///         `describeSurface()`.
    ///      d. Otherwise, the item's standard dynamic long description is fetched.
    ///   4. An `ActionResult` is returned with the generated message and any state changes.
    ///
    /// For ALL commands, processes each object individually and provides consolidated feedback.
    ///
    /// - Parameter context: The `ActionContext` for the current action.
    /// - Returns: An `ActionResult` containing the detailed description and any relevant state changes.
    /// - Throws: Can throw errors from engine calls if issues occur (e.g., item not found during processing).
    public func process(context: ActionContext) async throws -> ActionResult {
        // For ALL commands, empty directObjects is valid (means nothing to examine)
        if !context.command.isAllCommand {
            guard !context.command.directObjects.isEmpty else {
                return ActionResult("You can only examine items.")
            }
        }
        
        var allStateChanges: [StateChange] = []
        var messages: [String] = []
        var examinedItems: [Item] = []
        
        // Process each object individually
        for directObjectRef in context.command.directObjects {
            switch directObjectRef {
            case .item(let targetItemID):
                do {
                    let targetItem = try await context.engine.item(targetItemID)
                    
                    // Validate this specific item for ALL commands
                    if context.command.isAllCommand {
                        // Check if player can reach the item
                        guard await context.engine.playerCanReach(targetItemID) else {
                            continue // Skip unreachable items in ALL commands
                        }
                    }
                    
                    var itemStateChanges: [StateChange] = []
                    
                    // Special case: examining 'self' as an item should not record any state changes
                    if targetItem.id != "self" {
                        // --- State Change: Mark as Touched ---
                        if let update = await context.engine.setFlag(.isTouched, on: targetItem) {
                            itemStateChanges.append(update)
                        }
                        // Note: Pronoun updates are handled after processing all items
                    }
                    
                    // --- Determine Message ---
                    let message: String
                    // Priority 1: Readable Text (Check dynamic value)
                    if targetItem.hasFlag(.isReadable),
                       let readText: String = try? await context.engine.attribute(.readText, of: targetItem.id),
                       !readText.isEmpty
                    {
                        message = readText
                    }
                    // Priority 2: Container/Door Description
                    else if targetItem.hasFlag(.isContainer) || targetItem.hasFlag(.isDoor) {
                        message = try await describeContainerOrDoor(
                            targetItem: targetItem,
                            engine: context.engine
                        )
                    }
                    // Priority 3: Surface Description
                    else if targetItem.hasFlag(.isSurface) {
                        message = await describeSurface(
                            targetItem: targetItem,
                            engine: context.engine
                        )
                    }
                    // Priority 4: Dynamic Long Description
                    else {
                        // Use the registry to generate the description using the item ID and key
                        message = await context.engine.generateDescription(
                            for: targetItem.id,
                            attributeID: .description,
                            engine: context.engine
                        )
                    }
                    
                    allStateChanges.append(contentsOf: itemStateChanges)
                    examinedItems.append(targetItem)
                    
                    // For multiple objects, prefix with item name
                    if context.command.isAllCommand || context.command.directObjects.count > 1 {
                        messages.append("- \(targetItem.name.capitalizedFirst): \(message)")
                    } else {
                        messages.append(message)
                    }
                    
                } catch {
                    // For ALL commands, skip items that cause errors
                    if !context.command.isAllCommand {
                        throw error
                    }
                }
                
            case .player:
                // Classic Zork response for EXAMINE SELF
                if context.command.isAllCommand || context.command.directObjects.count > 1 {
                    messages.append("- Yourself: You are your usual self.")
                } else {
                    messages.append("You are your usual self.")
                }
                
            default:
                // For ALL commands, skip non-items
                if !context.command.isAllCommand {
                    return ActionResult("You can only examine items.")
                }
            }
        }
        
        // Update pronouns appropriately for multiple objects
        if !examinedItems.isEmpty {
            let lastItem = examinedItems.last!
            if examinedItems.count > 1 {
                // For multiple items, update both "it" and "them"
                let pronounChanges = await context.engine.updatePronounsForMultipleObjects(
                    lastItem: lastItem,
                    allItems: examinedItems
                )
                allStateChanges.append(contentsOf: pronounChanges)
            } else {
                // For single item, use the original method
                if let pronounChange = await context.engine.updatePronouns(to: lastItem) {
                    allStateChanges.append(pronounChange)
                }
            }
        }
        
        // Generate appropriate message
        let finalMessage: String
        if context.command.isAllCommand {
            if examinedItems.isEmpty && messages.isEmpty {
                finalMessage = "There is nothing here to examine."
            } else {
                finalMessage = messages.joined(separator: "\n")
            }
        } else {
            finalMessage = messages.joined(separator: "\n")
        }
        
        return ActionResult(
            message: finalMessage,
            stateChanges: allStateChanges
        )
    }

    // MARK: - Private Helpers (Adapted to return String)

    /// Generates a description for an item that is a container or a door.
    ///
    /// The description includes the item's base description followed by information about
    /// its contents (if open or transparent) or its closed state.
    ///
    /// - Parameters:
    ///   - targetItem: The container or door `Item` to describe.
    ///   - engine: The `GameEngine` instance for accessing item state and utility functions.
    /// - Returns: A string describing the container or door and its state/contents.
    /// - Throws: Errors if fetching dynamic properties like `.isOpen` fails.
    private func describeContainerOrDoor(
        targetItem: Item,
        engine: GameEngine
    ) async throws -> String {
        var descriptionParts: [String] = []

        // Start with the item's main description, using the registry with ID and key
        let baseDescription = await engine.generateDescription(
            for: targetItem.id,
            attributeID: .description,
            engine: engine
        )
        descriptionParts.append(baseDescription)

        // Check dynamic property for open state
        let isOpen: Bool = try await engine.attribute(.isOpen, of: targetItem.id)
        let isTransparent = targetItem.hasFlag(.isTransparent)

        if isOpen || isTransparent {
            let contents = await engine.items(in: .item(targetItem.id))
            if contents.isEmpty {
                descriptionParts.append("The \(targetItem.name) is empty.")
            } else {
                let itemNames = contents.listWithIndefiniteArticles
                descriptionParts.append("The \(targetItem.name) contains \(itemNames).")
            }
        } else {
            descriptionParts.append("The \(targetItem.name) is closed.")
        }
        return descriptionParts.joined(separator: " ")
    }

    /// Generates a description for an item that is a surface.
    ///
    /// The description includes the item's base description followed by a list of any items
    /// currently on its surface.
    ///
    /// - Parameters:
    ///   - targetItem: The surface `Item` to describe.
    ///   - engine: The `GameEngine` instance for accessing item state and utility functions.
    /// - Returns: A string describing the surface and any items on it.
    private func describeSurface(targetItem: Item, engine: GameEngine) async -> String {
        var descriptionParts: [String] = []

        // Start with the item's main description, using the registry with ID and key
        let baseDescription = await engine.generateDescription(
            for: targetItem.id,
            attributeID: .description,
            engine: engine
        )
        descriptionParts.append(baseDescription)

        // List items on the surface
        let contents = await engine.items(in: .item(targetItem.id))
        if !contents.isEmpty {
            let itemNames = contents.listWithIndefiniteArticles
            descriptionParts.append(
                "On the \(targetItem.name) is \(itemNames)."
            )
        }

        return descriptionParts.joined(separator: " ")
    }
}
