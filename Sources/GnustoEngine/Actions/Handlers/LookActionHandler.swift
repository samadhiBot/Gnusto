import Foundation

/// Handles the "LOOK" command and its synonyms (e.g., "L"). It can also implicitly handle
/// "EXAMINE [ITEM]" logic if a direct object is provided with the LOOK command.
///
/// - When used without a direct object ("LOOK"), it describes the player's current location,
///   including its name, description, and any visible items.
/// - When used with a direct object that is an item ("LOOK [ITEM]" or "EXAMINE [ITEM]"),
///   it describes the specified item, including its contents if it's an open/transparent
///   container or a surface.
public struct LookActionHandler: ActionHandler {
    /// Validates the "LOOK" command.
    ///
    /// - If no direct object is provided, validation always succeeds.
    /// - If a direct object is provided:
    ///   1. It must refer to an item.
    ///   2. The item must exist.
    ///   3. The player must be able to reach the item.
    ///
    /// - Parameter context: The `ActionContext` for the current action.
    /// - Throws: `ActionResponse.prerequisiteNotMet` if the direct object is not an item,
    ///           `ActionResponse.unknownEntity` if the item does not exist, or
    ///           `ActionResponse.itemNotAccessible` if the item cannot be reached.
    public func validate(context: ActionContext) async throws {
        // LOOK (no direct object) always validates.
        guard let directObjectRef = context.command.directObject else {
            return
        }

        // If a direct object is present, it must be an item for LOOK/EXAMINE.
        guard case .item(let targetItemID) = directObjectRef else {
            // For now, only items are supported when a direct object is specified.
            throw ActionResponse.prerequisiteNotMet("You can only look at items this way.")
        }

        // EXAMINE [Item] - Ensure item exists and is reachable
        guard (try? await context.engine.item(targetItemID)) != nil else {
            throw ActionResponse.unknownEntity(directObjectRef) // Was unknownItem
        }

        // Check reachability using ScopeResolver
        guard await context.engine.playerCanReach(targetItemID) else {
            // Use a standard message even if item technically exists elsewhere
            throw ActionResponse.itemNotAccessible(targetItemID)
        }
    }

    /// Processes the "LOOK" command.
    ///
    /// - **LOOK (no direct object):**
    ///   1. Checks if the current location is dark. If so, prints the standard "pitch black" message.
    ///   2. Otherwise, prints the location's name and then its detailed description (generated by
    ///      `locationDescription(engine:showVerbose:stateSnapshot:)`).
    ///
    /// - **LOOK [ITEM] (or EXAMINE [ITEM]):**
    ///   1. Retrieves the target item (validation ensures it exists and is reachable).
    ///   2. Generates the item's base description using `engine.generateDescription()`.
    ///   3. Appends a description of its contents if it's a container or surface, using
    ///      `describeContents(of:engine:stateSnapshot:)`.
    ///   4. Creates a `StateChange` to set the `.isTouched` flag on the item.
    ///   5. Updates pronouns to refer to the item.
    ///   6. Returns an `ActionResult` with the combined description and state changes.
    ///
    /// - Parameter context: The `ActionContext` for the current action.
    /// - Returns: An `ActionResult` containing the description and any relevant `StateChange`s.
    /// - Throws: `ActionResponse.internalEngineError` or errors from engine calls if issues occur.
    public func process(context: ActionContext) async throws -> ActionResult {
        // LOOK (no direct object)
        guard let directObjectRef = context.command.directObject else {
            // 1. Check for darkness FIRST
            guard await context.engine.playerLocationIsLit() else {
                return ActionResult("It is pitch black. You are likely to be eaten by a grue.")
            }

            await context.engine.ioHandler.print(
                "--- \(try context.engine.playerLocation().name) ---",
                style: .strong
            )

            // 2. Location is lit, proceed with description
            return ActionResult(
                await locationDescription(
                    try context.engine.playerLocation(),
                    engine: context.engine,
                    showVerbose: true,
                    stateSnapshot: context.stateSnapshot
                )
            )
        }

        // EXAMINE [Object] - directObjectRef is non-nil here.
        // Validate ensures it's an .item, so we can extract targetItemID.
        guard case .item(let targetItemID) = directObjectRef else {
            // This should not be reached if validate is correct.
            throw ActionResponse.internalEngineError("Look: directObject was not an item in process.")
        }

        // Validation ensures item exists and is reachable
        let targetItem = try await context.engine.item(targetItemID)

        var stateChanges: [StateChange] = []

        // 1. Get base description using the registry
        var descriptionLines: [String] = []
        let baseDescription = await context.engine.generateDescription(
            for: targetItem.id, // Use item ID
            attributeID: .description, // Specify the key
            engine: context.engine
        )
        descriptionLines.append(baseDescription)

        // 2. Add container/surface contents
        // Pass the Item to the helper
        descriptionLines.append(
            contentsOf: await describeContents(
                of: targetItem,
                engine: context.engine,
                stateSnapshot: context.stateSnapshot
            )
        )

        // 3. Prepare state change (mark as touched)
        if let update = await context.engine.setFlag(.isTouched, on: targetItem) {
            stateChanges.append(update)
        }

        // 4: Update pronoun
        if let update = await context.engine.updatePronouns(to: targetItem) {
            stateChanges.append(update)
        }

        // 5. Combine description lines and return result
        return ActionResult(
            message: descriptionLines.joined(separator: "\n"),
            stateChanges: stateChanges
        )
    }

    // Default postProcess will print the message from ActionResult

    // MARK: - Helper Functions

    /// Generates a multi-line string describing the contents of a given item, if it's a
    /// container or surface.
    ///
    /// - For containers, it lists items inside if the container is open or transparent.
    ///   It states if the container is empty or closed.
    /// - For surfaces, it lists items on the surface.
    ///
    /// - Parameters:
    ///   - item: The `Item` whose contents are to be described.
    ///   - engine: The `GameEngine` instance, used for utility functions like list formatting.
    ///   - stateSnapshot: The `GameState` snapshot to ensure consistent view of item locations.
    /// - Returns: An array of strings, each representing a line of the contents description.
    ///            Returns an empty array if the item is not a container/surface or has no describable contents.
    private func describeContents(
        of item: Item,
        engine: GameEngine,
        stateSnapshot: GameState
    ) async -> [String] {
        var lines: [String] = []
        let itemID = item.id

        // Container contents
        if item.hasFlag(.isContainer) {
            // Check current state (open/closed)
            let isOpen = item.hasFlag(.isOpen)
            let isTransparent = item.hasFlag(.isTransparent)

            if isOpen || isTransparent {
                // Get items *inside* the container from the snapshot
                let contents = stateSnapshot.items.values.filter { $0.parent == .item(itemID) }
                if contents.isEmpty {
                    lines.append("The \(item.name) is empty.")
                } else {
                    lines.append(
                        // Use engine helper for formatting list
                        "The \(item.name) contains \(contents.listWithIndefiniteArticles)."
                    )
                }
            } else {
                // Closed and not transparent
                lines.append("The \(item.name) is closed.")
            }
        }

        // Surface contents - Check flag on item definition
        if item.hasFlag(.isSurface) { // Use flag()
            // Get items *on* the surface from the snapshot
            let itemsOnSurface = stateSnapshot.items.values.filter { $0.parent == .item(itemID) }
            // Filter out the item itself if it somehow lists itself (e.g., bug)
            let itemsToDescribe = itemsOnSurface.filter { $0.id != itemID }
            if !itemsOnSurface.isEmpty {
                // Use engine helper for formatting
                let isAre = itemsToDescribe.count == 1 ? "is" : "are"
                lines.append(
                    "On the \(item.name) \(isAre) \(itemsToDescribe.listWithIndefiniteArticles)."
                )
            }
            // No message needed if surface is empty
        }
        return lines
    }

    /// Generates a comprehensive description of the specified location, including its standard
    /// description and a list of any visible items.
    ///
    /// - Parameters:
    ///   - location: The `Location` to describe.
    ///   - engine: The `GameEngine` instance, used for description generation and scope resolution.
    ///   - showVerbose: A flag (currently unused but planned) that might control the level of detail.
    ///   - stateSnapshot: The `GameState` snapshot, used to retrieve item details.
    /// - Returns: A string containing the full description of the location and its visible items.
    private func locationDescription(
        _ location: Location,
        engine: GameEngine,
        showVerbose: Bool,
        stateSnapshot: GameState
    ) async -> String {
        var description: [String] = [
            await engine.generateDescription(
                for: location.id,
                attributeID: .description,
                engine: engine
            )
        ]

        // Use the correct ScopeResolver method
        let visibleItemIDs = await engine.scopeResolver.visibleItemsIn(locationID: location.id)

        // Filter out the player if present in scope (shouldn't happen normally)
        // let itemIDsToDescribe = visibleItemIDs.filter { $0 != .player }

        // guard !itemIDsToDescribe.isEmpty else { return } // Exit if no items to list

        // Original implementation using sentence format: - RESTORE THIS

        let visibleItems = visibleItemIDs.compactMap { stateSnapshot.items[$0] }

        if !visibleItems.isEmpty {
            let itemListing = visibleItems.listWithIndefiniteArticles
            description.append("You can see \(itemListing) here.")
        }

        return description.joined(separator: "\n")
    }
}
