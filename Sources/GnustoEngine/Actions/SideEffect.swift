import Foundation

/// Represents an imperative action or an indirect consequence of a player's command that
/// doesn't directly modify a `GameState` property via a `StateChange`.
///
/// `SideEffect`s are used for operations like starting or stopping timed events (fuses),
/// managing background processes (daemons), or scheduling future events. They are typically
/// generated by an `ActionHandler` as part of an `ActionResult` and then processed by the
/// `GameEngine`.
public struct SideEffect: Sendable, Equatable {
    /// The specific category or kind of this side effect.
    public let type: SideEffectType

    /// The `EntityID` of the primary entity involved in or targeted by this side effect.
    /// For example, for `.startFuse`, this would be the `EntityID.fuse(fuseID)` of the fuse to start.
    /// For effects not tied to a specific entity, `.global` might be used.
    public let targetID: EntityID

    /// Strongly-typed payload data required to execute this side effect.
    /// The payload type depends on the `SideEffectType` and contains all necessary
    /// configuration and data for the operation.
    public let payload: AnyCodableSendable?

    /// Creates a new `SideEffect` with a strongly-typed payload.
    ///
    /// - Parameters:
    ///   - type: The category of side effect to create.
    ///   - targetID: The primary entity involved in this side effect.
    ///   - payload: Strongly-typed payload data for the operation.
    public init<T: Codable & Sendable>(
        type: SideEffectType,
        targetID: EntityID,
        payload: T
    ) throws {
        self.type = type
        self.targetID = targetID
        self.payload = try AnyCodableSendable(payload)
    }

    /// Creates a new `SideEffect` without payload data.
    ///
    /// - Parameters:
    ///   - type: The category of side effect to create.
    ///   - targetID: The primary entity involved in this side effect.
    public init(
        type: SideEffectType,
        targetID: EntityID
    ) {
        self.type = type
        self.targetID = targetID
        self.payload = nil
    }

    /// Retrieves the payload as a specific type.
    ///
    /// - Parameter type: The expected type of the payload.
    /// - Returns: The decoded payload, or `nil` if no payload exists or decoding fails.
    public func getPayload<T: Codable & Sendable>(as type: T.Type) -> T? {
        return payload?.tryDecode(as: type)
    }
}

// MARK: - SideEffect Factories

extension SideEffect {
    /// Creates a new `SideEffect` instance with type `.startFuse` using a `FuseState`.
    ///
    /// This is the modern approach for starting fuses with type-safe payload data.
    /// The `FuseState` contains both the turn count and any custom payload data.
    ///
    /// - Parameters:
    ///   - fuseID: The `FuseID` of the fuse to start.
    ///   - state: The `FuseState` containing turns and payload data.
    /// - Returns: A configured `SideEffect` for starting the fuse.
    public static func startFuse(
        _ fuseID: FuseID,
        state: FuseState
    ) -> SideEffect {
        return try! SideEffect(
            type: .startFuse,
            targetID: .fuse(fuseID),
            payload: state
        )
    }

    /// Creates a new `SideEffect` instance with type `.startFuse` using default turns from the fuse definition.
    ///
    /// This convenience method creates a `FuseState` with no custom payload data.
    ///
    /// - Parameter fuseID: The `FuseID` of the fuse to start.
    /// - Returns: A configured `SideEffect` for starting the fuse.
    public static func startFuse(_ fuseID: FuseID) -> SideEffect {
        // We need to get the default turns from somewhere. Since we can't access the fuse definition
        // here, we'll create a simple FuseState with a reasonable default and let the engine
        // override with the actual definition's initialTurns if needed.
        let fuseState = FuseState(turns: nil)  // Engine will use definition's initialTurns
        return startFuse(fuseID, state: fuseState)
    }

    /// Creates a new `SideEffect` instance with type `.startFuse` with custom turns and no payload.
    ///
    /// - Parameters:
    ///   - fuseID: The `FuseID` of the fuse to start.
    ///   - turns: The number of turns until the fuse triggers.
    /// - Returns: A configured `SideEffect` for starting the fuse.
    public static func startFuse(_ fuseID: FuseID, turns: Int) -> SideEffect {
        let fuseState = FuseState(turns: turns)
        return startFuse(fuseID, state: fuseState)
    }

    /// Creates a new `SideEffect` instance with type `.stopFuse`.
    ///
    /// - Parameter fuseID: The `FuseID` of the fuse to stop.
    /// - Returns: A configured `SideEffect` for stopping the fuse.
    public static func stopFuse(_ fuseID: FuseID) -> SideEffect {
        return SideEffect(
            type: .stopFuse,
            targetID: .fuse(fuseID)
        )
    }

    /// Creates a new `SideEffect` instance with type `.runDaemon` using a `DaemonState`.
    ///
    /// - Parameters:
    ///   - daemonID: The `DaemonID` of the daemon to run.
    ///   - state: The `DaemonState` containing execution data and payload.
    /// - Returns: A configured `SideEffect` for running the daemon.
    public static func runDaemon(
        _ daemonID: DaemonID,
        state: DaemonState
    ) -> SideEffect {
        return try! SideEffect(
            type: .runDaemon,
            targetID: .daemon(daemonID),
            payload: state
        )
    }

    /// Creates a new `SideEffect` instance with type `.runDaemon` without initial state.
    ///
    /// - Parameter daemonID: The `DaemonID` of the daemon to run.
    /// - Returns: A configured `SideEffect` for running the daemon.
    public static func runDaemon(_ daemonID: DaemonID) -> SideEffect {
        return SideEffect(
            type: .runDaemon,
            targetID: .daemon(daemonID)
        )
    }

    /// Creates a new `SideEffect` instance with type `.stopDaemon`.
    ///
    /// - Parameter daemonID: The `DaemonID` of the daemon to stop.
    /// - Returns: A configured `SideEffect` for stopping the daemon.
    public static func stopDaemon(_ daemonID: DaemonID) -> SideEffect {
        return SideEffect(
            type: .stopDaemon,
            targetID: .daemon(daemonID)
        )
    }
}

// MARK: - Convenience Methods for Common Fuse Patterns

extension SideEffect {
    /// Starts an enemy wake-up fuse with a specific enemy ID.
    ///
    /// This convenience method creates a properly configured side effect for waking up
    /// an unconscious enemy after a specified number of turns.
    ///
    /// - Parameters:
    ///   - enemyID: The ID of the enemy that should wake up.
    ///   - locationID: The ID of the location where the wake-up occurs.
    ///   - message: The message to display if the player is present when the enemy wakes up.
    ///   - turns: Number of turns until the enemy wakes up. Defaults to 3.
    /// - Returns: A configured SideEffect for the enemy wake-up fuse.
    public static func startEnemyWakeUpFuse(
        enemyID: ItemID,
        locationID: LocationID,
        message: String,
        turns: Int = 3
    ) -> SideEffect {
        let payload = FuseState.EnemyLocationPayload(
            enemyID: enemyID,
            locationID: locationID,
            message: message
        )
        let fuseState = try! FuseState(turns: turns, payload: payload)
        return startFuse(.enemyWakeUp, state: fuseState)
    }

    /// Starts an enemy return fuse with specific enemy and location IDs.
    ///
    /// This convenience method creates a properly configured side effect for returning
    /// an enemy to a specific location after a specified number of turns. This prevents
    /// the enemy from spawning in the player's current location.
    ///
    /// - Parameters:
    ///   - enemyID: The ID of the enemy that should return.
    ///   - locationID: The ID of the location where the enemy should return.
    ///   - message: The message to display if the player is present when the enemy returns.
    ///   - turns: Number of turns until the enemy returns. Defaults to 3.
    /// - Returns: A configured SideEffect for the enemy return fuse.
    public static func startEnemyReturnFuse(
        enemyID: ItemID,
        to locationID: LocationID,
        message: String,
        turns: Int = 3
    ) -> SideEffect {
        let payload = FuseState.EnemyLocationPayload(
            enemyID: enemyID,
            locationID: locationID,
            message: message
        )
        let fuseState = try! FuseState(turns: turns, payload: payload)
        return startFuse(.enemyReturn, state: fuseState)
    }

    /// Starts a status effect expiry fuse with item and effect details.
    ///
    /// This convenience method creates a side effect for removing temporary status
    /// effects from items after a specified duration.
    ///
    /// - Parameters:
    ///   - itemID: The ID of the item affected by the status effect.
    ///   - effectName: A string identifier for the specific effect to remove.
    ///   - turns: Number of turns until the effect expires. Defaults to 5.
    /// - Returns: A configured SideEffect for the status effect expiry fuse.
    public static func startStatusEffectExpiryFuse(
        for itemID: ItemID,
        effectName: String,
        turns: Int = 5
    ) -> SideEffect {
        let payload = FuseState.StatusEffectPayload(
            itemID: itemID,
            effectName: effectName
        )
        let fuseState = try! FuseState(turns: turns, payload: payload)
        return startFuse(.statusEffectExpiry, state: fuseState)
    }

    /// Starts an environmental change fuse with custom parameters.
    ///
    /// This convenience method creates a side effect for delayed environmental changes
    /// such as weather transitions, lighting changes, or atmospheric modifications.
    ///
    /// - Parameters:
    ///   - changeType: A string describing the type of environmental change.
    ///   - parameters: A dictionary of additional parameters for the change.
    ///   - turns: Number of turns until the change occurs. Defaults to 2.
    /// - Returns: A configured SideEffect for the environmental change fuse.
    public static func startEnvironmentalChangeFuse(
        changeType: String,
        parameters: [String: String] = [:],
        turns: Int = 2
    ) throws -> SideEffect {
        let payload = FuseState.EnvironmentalPayload(
            changeType: changeType,
            parameters: parameters
        )
        let fuseState = try! FuseState(turns: turns, payload: payload)
        return startFuse(.environmentalChange, state: fuseState)
    }
}

// MARK: - SideEffectType

/// Enumerates the distinct categories of side effects that can be triggered within the game.
///
/// Each case represents a specific type of imperative action that the `GameEngine` can perform
/// in response to game events or player commands.
public enum SideEffectType: String, Codable, Sendable, Equatable {
    /// Indicates that a timed event (a "fuse") should be started.
    /// The `targetID` in the `SideEffect` should be the `EntityID.fuse(fuseID)` of the fuse.
    /// The payload should contain a `FuseState` with timing and custom data.
    case startFuse

    /// Indicates that an active fuse should be stopped before it naturally concludes.
    /// The `targetID` should be the `EntityID.fuse(fuseID)` of the fuse to stop.
    /// No payload is required.
    case stopFuse

    /// Indicates that a background game logic component (a "daemon") should be activated.
    /// The `targetID` should be the `EntityID.daemon(daemonID)` of the daemon to run.
    /// The payload may contain a `DaemonState` with initial execution data.
    case runDaemon

    /// Indicates that an active daemon should be deactivated.
    /// The `targetID` should be the `EntityID.daemon(daemonID)` of the daemon to stop.
    /// No payload is required.
    case stopDaemon
}
