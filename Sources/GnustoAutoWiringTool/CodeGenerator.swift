import Foundation

struct CodeGenerator {
    func generate(from gameData: GameData) -> String {
        var output = [
            "// Generated by GnustoAutoWiringPlugin",
            "// Do not edit this file manually",
            "",
            "import GnustoEngine",
            "",
        ]

        // Check if there's anything to generate
        let hasContent =
            !gameData.locationIDs.isEmpty || !gameData.itemIDs.isEmpty
            || !gameData.globalIDs.isEmpty || !gameData.fuseIDs.isEmpty
            || !gameData.daemonIDs.isEmpty || !gameData.verbIDs.isEmpty
            || !gameData.gameBlueprintTypes.isEmpty

        guard hasContent else {
            output.append("// No ID constants or GameBlueprint extensions need to be generated.")
            output.append("")
            return output.joined(separator: "\n")
        }

        // Generate ID Extensions
        generateIDExtensions(for: gameData, output: &output)

        // Generate GameBlueprint Extensions
        generateGameBlueprintExtensions(for: gameData, output: &output)

        return output.joined(separator: "\n")
    }

    private func generateIDExtensions(for gameData: GameData, output: inout [String]) {
        if !gameData.locationIDs.isEmpty {
            output.append("extension LocationID {")
            for locationID in gameData.locationIDs.keys.sorted() {
                output.append("    static let \(locationID) = LocationID(\"\(locationID)\")")
            }
            output.append("}")
            output.append("")
        }

        if !gameData.itemIDs.isEmpty {
            output.append("extension ItemID {")
            for itemID in gameData.itemIDs.keys.sorted() {
                output.append("    static let \(itemID) = ItemID(\"\(itemID)\")")
            }
            output.append("}")
            output.append("")
        }

        if !gameData.globalIDs.isEmpty {
            output.append("extension GlobalID {")
            for globalID in gameData.globalIDs.keys.sorted() {
                output.append("    static let \(globalID) = GlobalID(\"\(globalID)\")")
            }
            output.append("}")
            output.append("")
        }

        if !gameData.fuseIDs.isEmpty {
            output.append("extension FuseID {")
            for fuseID in gameData.fuseIDs.keys.sorted() {
                output.append("    static let \(fuseID) = FuseID(\"\(fuseID)\")")
            }
            output.append("}")
            output.append("")
        }

        if !gameData.daemonIDs.isEmpty {
            output.append("extension DaemonID {")
            for daemonID in gameData.daemonIDs.keys.sorted() {
                output.append("    static let \(daemonID) = DaemonID(\"\(daemonID)\")")
            }
            output.append("}")
            output.append("")
        }

        if !gameData.verbIDs.isEmpty {
            output.append("extension Verb {")
            for verbID in gameData.verbIDs.keys.sorted() {
                output.append("    static let \(verbID) = Verb(\"\(verbID)\")")
            }
            output.append("}")
            output.append("")
        }
    }

    private func generateGameBlueprintExtensions(for gameData: GameData, output: inout [String]) {
        for gameBlueprintType in gameData.gameBlueprintTypes.sorted() {
            var extensionLines = [String]()

            // Only generate extension if there's content
            if !gameData.items.isEmpty || !gameData.locations.isEmpty
                || !gameData.itemEventHandlers.isEmpty || !gameData.locationEventHandlers.isEmpty
                || !gameData.combatSystems.isEmpty || !gameData.combatMessengers.isEmpty
                || !gameData.itemComputeHandlers.isEmpty
                || !gameData.locationComputeHandlers.isEmpty || !gameData.daemons.isEmpty
                || !gameData.fuses.isEmpty
            {
                output.append("extension \(gameBlueprintType) {")

                // Generate items property
                if !gameData.items.isEmpty {
                    extensionLines.append("    public var items: [Item] {")

                    // Collect area instances needed for items
                    var itemAreaInstances: Set<String> = []
                    for itemProperty in gameData.items.sorted() {
                        if let areaType = gameData.itemToAreaMap[itemProperty] {
                            let isStatic = gameData.propertyIsStatic[itemProperty] ?? true
                            if !isStatic {
                                itemAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in itemAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !itemAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    let returnStatement = itemAreaInstances.isEmpty ? "" : "return "

                    extensionLines.append("        \(returnStatement)[")

                    for itemProperty in gameData.items.sorted() {
                        if let areaType = gameData.itemToAreaMap[itemProperty] {
                            let isStatic = gameData.propertyIsStatic[itemProperty] ?? true
                            if isStatic {
                                extensionLines.append("            \(areaType).\(itemProperty),")
                            } else {
                                extensionLines.append(
                                    "            \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(itemProperty),"
                                )
                            }
                        } else {
                            // When area mapping is unknown, skip rather than guessing wrong
                            extensionLines.append(
                                "            // \(itemProperty), // Area mapping unknown - please add manually"
                            )
                        }
                    }

                    extensionLines.append("        ]")
                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate locations property
                if !gameData.locations.isEmpty {
                    extensionLines.append("    public var locations: [Location] {")

                    // Collect area instances needed for locations
                    var locationAreaInstances: Set<String> = []
                    for locationProperty in gameData.locations.sorted() {
                        if let areaType = gameData.locationToAreaMap[locationProperty] {
                            let isStatic = gameData.propertyIsStatic[locationProperty] ?? true
                            if !isStatic {
                                locationAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in locationAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !locationAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    let returnStatement = locationAreaInstances.isEmpty ? "" : "return "

                    extensionLines.append("        \(returnStatement)[")

                    for locationProperty in gameData.locations.sorted() {
                        if let areaType = gameData.locationToAreaMap[locationProperty] {
                            let isStatic = gameData.propertyIsStatic[locationProperty] ?? true
                            if isStatic {
                                extensionLines.append(
                                    "            \(areaType).\(locationProperty),")
                            } else {
                                extensionLines.append(
                                    "            \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(locationProperty),"
                                )
                            }
                        } else {
                            // When area mapping is unknown, skip rather than guessing wrong
                            extensionLines.append(
                                "            // \(locationProperty), // Area mapping unknown - please add manually"
                            )
                        }
                    }

                    extensionLines.append("        ]")
                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate itemEventHandlers property
                if !gameData.itemEventHandlers.isEmpty {
                    extensionLines.append(
                        "    public var itemEventHandlers: [ItemID: ItemEventHandler] {")

                    // Collect area instances needed for item event handlers
                    var itemHandlerAreaInstances: Set<String> = []
                    for itemHandler in gameData.itemEventHandlers {
                        if let areaType = gameData.handlerToAreaMap[itemHandler] {
                            let handlerPropertyName = "\(itemHandler)Handler"
                            let isStatic = gameData.propertyIsStatic[handlerPropertyName] ?? true
                            if !isStatic {
                                itemHandlerAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in itemHandlerAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !itemHandlerAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    // Check if we have any mapped handlers before generating the return statement
                    let mappedHandlers = gameData.itemEventHandlers.filter { handler in
                        gameData.handlerToAreaMap[handler] != nil
                    }

                    let returnStatement = itemHandlerAreaInstances.isEmpty ? "" : "return "

                    if mappedHandlers.isEmpty {
                        extensionLines.append("        \(returnStatement)[:]")
                    } else {
                        extensionLines.append("        \(returnStatement)[")

                        for itemHandler in gameData.itemEventHandlers.sorted() {
                            if let areaType = gameData.handlerToAreaMap[itemHandler] {
                                let handlerPropertyName = "\(itemHandler)Handler"
                                let isStatic =
                                    gameData.propertyIsStatic[handlerPropertyName] ?? true
                                if isStatic {
                                    extensionLines.append(
                                        "            .\(itemHandler): \(areaType).\(handlerPropertyName),"
                                    )
                                } else {
                                    extensionLines.append(
                                        "            .\(itemHandler): \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(handlerPropertyName),"
                                    )
                                }
                            } else {
                                extensionLines.append(
                                    "            // .\(itemHandler): SomeArea.\(itemHandler)Handler, // Area mapping unknown - please add manually"
                                )
                            }
                        }

                        extensionLines.append("        ]")
                    }

                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate combatMessengers property
                if !gameData.combatMessengers.isEmpty {
                    extensionLines.append(
                        "    public var combatMessengers: [ItemID: CombatMessenger] {")

                    // Collect area instances needed for combat messengers
                    var combatMessengerAreaInstances: Set<String> = []
                    for combatMessenger in gameData.combatMessengers {
                        if let areaType = gameData.handlerToAreaMap[combatMessenger] {
                            let isStatic = gameData.propertyIsStatic[combatMessenger] ?? true
                            if !isStatic {
                                combatMessengerAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in combatMessengerAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !combatMessengerAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    // Check if we have any mapped combat messengers before generating the return statement
                    let mappedCombatMessengers = gameData.combatMessengers.filter {
                        combatMessenger in
                        gameData.handlerToAreaMap[combatMessenger] != nil
                    }

                    let returnStatement = combatMessengerAreaInstances.isEmpty ? "" : "return "

                    if mappedCombatMessengers.isEmpty {
                        extensionLines.append("        \(returnStatement)[:]")
                    } else {
                        extensionLines.append("        \(returnStatement)[")

                        for combatMessenger in gameData.combatMessengers.sorted() {
                            if let areaType = gameData.handlerToAreaMap[combatMessenger] {
                                // Infer the enemy ID from the combat messenger property name
                                var enemyID = combatMessenger
                                if enemyID.hasSuffix("CombatMessenger") {
                                    enemyID = String(enemyID.dropLast("CombatMessenger".count))
                                } else if enemyID.hasSuffix("Messenger") {
                                    enemyID = String(enemyID.dropLast("Messenger".count))
                                }

                                let isStatic = gameData.propertyIsStatic[combatMessenger] ?? true
                                if isStatic {
                                    extensionLines.append(
                                        "            .\(enemyID): \(areaType).\(combatMessenger),")
                                } else {
                                    extensionLines.append(
                                        "            .\(enemyID): \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(combatMessenger),"
                                    )
                                }
                            } else {
                                // Infer the enemy ID for the comment as well
                                var enemyID = combatMessenger
                                if enemyID.hasSuffix("CombatMessenger") {
                                    enemyID = String(enemyID.dropLast("CombatMessenger".count))
                                } else if enemyID.hasSuffix("Messenger") {
                                    enemyID = String(enemyID.dropLast("Messenger".count))
                                }
                                extensionLines.append(
                                    "            // .\(enemyID): SomeArea.\(combatMessenger), // Area mapping unknown - please add manually"
                                )
                            }
                        }

                        extensionLines.append("        ]")
                    }

                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate combatSystems property
                if !gameData.combatSystems.isEmpty {
                    extensionLines.append(
                        "    public var combatSystems: [ItemID: any CombatSystem] {")

                    // Collect area instances needed for combat systems
                    var combatSystemAreaInstances: Set<String> = []
                    for combatSystem in gameData.combatSystems {
                        if let areaType = gameData.handlerToAreaMap[combatSystem] {
                            let isStatic = gameData.propertyIsStatic[combatSystem] ?? true
                            if !isStatic {
                                combatSystemAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in combatSystemAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !combatSystemAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    // Check if we have any mapped combat systems before generating the return statement
                    let mappedCombatSystems = gameData.combatSystems.filter { combatSystem in
                        gameData.handlerToAreaMap[combatSystem] != nil
                    }

                    let returnStatement = combatSystemAreaInstances.isEmpty ? "" : "return "

                    if mappedCombatSystems.isEmpty {
                        extensionLines.append("        \(returnStatement)[:]")
                    } else {
                        extensionLines.append("        \(returnStatement)[")

                        for combatSystem in gameData.combatSystems.sorted() {
                            if let areaType = gameData.handlerToAreaMap[combatSystem] {
                                // Infer the enemy ID from the combat system property name
                                var enemyID = combatSystem
                                if enemyID.hasSuffix("CombatSystem") {
                                    enemyID = String(enemyID.dropLast("CombatSystem".count))
                                } else if enemyID.hasSuffix("Combat") {
                                    enemyID = String(enemyID.dropLast("Combat".count))
                                }

                                let isStatic = gameData.propertyIsStatic[combatSystem] ?? true
                                if isStatic {
                                    extensionLines.append(
                                        "            .\(enemyID): \(areaType).\(combatSystem),")
                                } else {
                                    extensionLines.append(
                                        "            .\(enemyID): \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(combatSystem),"
                                    )
                                }
                            } else {
                                // Infer the enemy ID for the comment as well
                                var enemyID = combatSystem
                                if enemyID.hasSuffix("CombatSystem") {
                                    enemyID = String(enemyID.dropLast("CombatSystem".count))
                                } else if enemyID.hasSuffix("Combat") {
                                    enemyID = String(enemyID.dropLast("Combat".count))
                                }
                                extensionLines.append(
                                    "            // .\(enemyID): SomeArea.\(combatSystem), // Area mapping unknown - please add manually"
                                )
                            }
                        }

                        extensionLines.append("        ]")
                    }

                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate locationEventHandlers property
                if !gameData.locationEventHandlers.isEmpty {
                    extensionLines.append(
                        "    public var locationEventHandlers: [LocationID: LocationEventHandler] {"
                    )

                    // Collect area instances needed for location event handlers
                    var locationHandlerAreaInstances: Set<String> = []
                    for locationHandler in gameData.locationEventHandlers {
                        if let areaType = gameData.handlerToAreaMap[locationHandler] {
                            let handlerPropertyName = "\(locationHandler)Handler"
                            let isStatic = gameData.propertyIsStatic[handlerPropertyName] ?? true
                            if !isStatic {
                                locationHandlerAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in locationHandlerAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !locationHandlerAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    // Check if we have any mapped handlers before generating the return statement
                    let mappedHandlers = gameData.locationEventHandlers.filter { handler in
                        gameData.handlerToAreaMap[handler] != nil
                    }

                    let returnStatement = locationHandlerAreaInstances.isEmpty ? "" : "return "

                    if mappedHandlers.isEmpty {
                        extensionLines.append("        \(returnStatement)[:]")
                    } else {
                        extensionLines.append("        \(returnStatement)[")

                        for locationHandler in gameData.locationEventHandlers.sorted() {
                            if let areaType = gameData.handlerToAreaMap[locationHandler] {
                                let handlerPropertyName = "\(locationHandler)Handler"
                                let isStatic =
                                    gameData.propertyIsStatic[handlerPropertyName] ?? true
                                if isStatic {
                                    extensionLines.append(
                                        "            .\(locationHandler): \(areaType).\(handlerPropertyName),"
                                    )
                                } else {
                                    extensionLines.append(
                                        "            .\(locationHandler): \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(handlerPropertyName),"
                                    )
                                }
                            } else {
                                extensionLines.append(
                                    "            // .\(locationHandler): SomeArea.\(locationHandler)Handler, // Area mapping unknown - please add manually"
                                )
                            }
                        }

                        extensionLines.append("        ]")
                    }

                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate daemons property
                if !gameData.daemons.isEmpty {
                    extensionLines.append("    public var daemons: [DaemonID: Daemon] {")

                    // Collect area instances needed for daemons
                    var daemonAreaInstances: Set<String> = []
                    for daemon in gameData.daemons {
                        if let areaType = gameData.handlerToAreaMap[daemon] {
                            let isStatic = gameData.propertyIsStatic[daemon] ?? true
                            if !isStatic {
                                daemonAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in daemonAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !daemonAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    // Check if we have any mapped daemon definitions before generating the return statement
                    let mappedDaemons = gameData.daemons.filter { daemon in
                        gameData.handlerToAreaMap[daemon] != nil
                    }

                    let returnStatement = daemonAreaInstances.isEmpty ? "" : "return "

                    if mappedDaemons.isEmpty {
                        extensionLines.append("        \(returnStatement)[:]")
                    } else {
                        extensionLines.append("        \(returnStatement)[")

                        for daemonProperty in gameData.daemons.sorted() {
                            if let areaType = gameData.handlerToAreaMap[daemonProperty] {
                                let isStatic = gameData.propertyIsStatic[daemonProperty] ?? true
                                // Use property name directly as daemon ID (since Daemon no longer has embedded ID)
                                let daemonID = daemonProperty

                                if isStatic {
                                    extensionLines.append(
                                        "            .\(daemonID): \(areaType).\(daemonProperty),")
                                } else {
                                    extensionLines.append(
                                        "            .\(daemonID): \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(daemonProperty),"
                                    )
                                }
                            } else {
                                extensionLines.append(
                                    "            // .\(daemonProperty): SomeArea.\(daemonProperty), // Area mapping unknown - please add manually"
                                )
                            }
                        }

                        extensionLines.append("        ]")
                    }

                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate fuses property
                if !gameData.fuses.isEmpty {
                    extensionLines.append("    public var fuses: [FuseID: Fuse] {")

                    // Collect area instances needed for fuses
                    var fuseAreaInstances: Set<String> = []
                    for fuse in gameData.fuses {
                        if let areaType = gameData.handlerToAreaMap[fuse] {
                            let isStatic = gameData.propertyIsStatic[fuse] ?? true
                            if !isStatic {
                                fuseAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in fuseAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !fuseAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    // Check if we have any mapped fuse definitions before generating the return statement
                    let mappedFuses = gameData.fuses.filter { fuse in
                        gameData.handlerToAreaMap[fuse] != nil
                    }

                    let returnStatement = fuseAreaInstances.isEmpty ? "" : "return "

                    if mappedFuses.isEmpty {
                        extensionLines.append("        \(returnStatement)[:]")
                    } else {
                        extensionLines.append("        \(returnStatement)[")

                        for fuseProperty in gameData.fuses.sorted() {
                            if let areaType = gameData.handlerToAreaMap[fuseProperty] {
                                let isStatic = gameData.propertyIsStatic[fuseProperty] ?? true
                                // Use property name directly as fuse ID (since Fuse no longer has embedded ID)
                                let fuseID = fuseProperty

                                if isStatic {
                                    extensionLines.append(
                                        "            .\(fuseID): \(areaType).\(fuseProperty),")
                                } else {
                                    extensionLines.append(
                                        "            .\(fuseID): \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(fuseProperty),"
                                    )
                                }
                            } else {
                                extensionLines.append(
                                    "            // .\(fuseProperty): SomeArea.\(fuseProperty), // Area mapping unknown - please add manually"
                                )
                            }
                        }

                        extensionLines.append("        ]")
                    }

                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate itemComputers property
                if !gameData.itemComputeHandlers.isEmpty {
                    extensionLines.append("    public var itemComputers: [ItemID: ItemComputer] {")

                    // Collect area instances needed for item compute handlers
                    var itemComputeAreaInstances: Set<String> = []
                    for itemHandler in gameData.itemComputeHandlers {
                        if let areaType = gameData.handlerToAreaMap[itemHandler] {
                            let handlerPropertyName = "\(itemHandler)Computer"
                            let isStatic = gameData.propertyIsStatic[handlerPropertyName] ?? true
                            if !isStatic {
                                itemComputeAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in itemComputeAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !itemComputeAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    // Check if we have any mapped handlers before generating the return statement
                    let mappedHandlers = gameData.itemComputeHandlers.filter { handler in
                        gameData.handlerToAreaMap[handler] != nil
                    }

                    let returnStatement = itemComputeAreaInstances.isEmpty ? "" : "return "

                    if mappedHandlers.isEmpty {
                        extensionLines.append("        \(returnStatement)[:]")
                    } else {
                        extensionLines.append("        \(returnStatement)[")

                        for itemHandler in gameData.itemComputeHandlers.sorted() {
                            if let areaType = gameData.handlerToAreaMap[itemHandler] {
                                let handlerPropertyName = "\(itemHandler)Computer"
                                let isStatic =
                                    gameData.propertyIsStatic[handlerPropertyName] ?? true

                                if isStatic {
                                    extensionLines.append(
                                        "            .\(itemHandler): \(areaType).\(handlerPropertyName),"
                                    )
                                } else {
                                    extensionLines.append(
                                        "            .\(itemHandler): \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(handlerPropertyName),"
                                    )
                                }
                            } else {
                                extensionLines.append(
                                    "            // .\(itemHandler): SomeArea.\(itemHandler)Computer, // Area mapping unknown - please add manually"
                                )
                            }
                        }

                        extensionLines.append("        ]")
                    }

                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                // Generate locationComputers property
                if !gameData.locationComputeHandlers.isEmpty {
                    extensionLines.append(
                        "    public var locationComputers: [LocationID: LocationComputer] {")

                    // Collect area instances needed for location compute handlers
                    var locationComputeAreaInstances: Set<String> = []
                    for locationHandler in gameData.locationComputeHandlers {
                        if let areaType = gameData.handlerToAreaMap[locationHandler] {
                            let handlerPropertyName = "\(locationHandler)Computer"
                            let isStatic = gameData.propertyIsStatic[handlerPropertyName] ?? true
                            if !isStatic {
                                locationComputeAreaInstances.insert(areaType)
                            }
                        }
                    }

                    // Create area instances within this property if needed
                    for areaType in locationComputeAreaInstances.sorted() {
                        extensionLines.append(
                            "        let \(areaType.prefix(1).lowercased() + areaType.dropFirst()) = \(areaType)()"
                        )
                    }

                    if !locationComputeAreaInstances.isEmpty {
                        extensionLines.append("")
                    }

                    // Check if we have any mapped handlers before generating the return statement
                    let mappedHandlers = gameData.locationComputeHandlers.filter { handler in
                        gameData.handlerToAreaMap[handler] != nil
                    }

                    let returnStatement = locationComputeAreaInstances.isEmpty ? "" : "return "

                    if mappedHandlers.isEmpty {
                        extensionLines.append("        \(returnStatement)[:]")
                    } else {
                        extensionLines.append("        \(returnStatement)[")

                        for locationHandler in gameData.locationComputeHandlers.sorted() {
                            if let areaType = gameData.handlerToAreaMap[locationHandler] {
                                let handlerPropertyName = "\(locationHandler)Computer"
                                let isStatic =
                                    gameData.propertyIsStatic[handlerPropertyName] ?? true

                                if isStatic {
                                    extensionLines.append(
                                        "            .\(locationHandler): \(areaType).\(handlerPropertyName),"
                                    )
                                } else {
                                    extensionLines.append(
                                        "            .\(locationHandler): \(areaType.prefix(1).lowercased() + areaType.dropFirst()).\(handlerPropertyName),"
                                    )
                                }
                            } else {
                                extensionLines.append(
                                    "            // .\(locationHandler): SomeArea.\(locationHandler)Computer, // Area mapping unknown - please add manually"
                                )
                            }
                        }

                        extensionLines.append("        ]")
                    }

                    extensionLines.append("    }")
                    extensionLines.append("")
                }

                output.append(contentsOf: extensionLines)
                output.append("}")
                output.append("")
            }
        }
    }
}
